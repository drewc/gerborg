#+TITLE:      Org Element API
#+AUTHOR:     Nicolas Goaziou
#+EMAIL:      mail@nicolasgoaziou.fr
#+STARTUP:    align fold nodlcheck hidestars oddeven lognotestate
#+SEQ_TODO:   TODO(t) INPROGRESS(i) WAITING(w@) | DONE(d) CANCELED(c@)
#+TAGS:       Write(w) Update(u) Fix(f) Check(c) NEW(n) Object(o) Element(e) GreaterElement(g)
#+LANGUAGE:   en
#+PRIORITIES: A C B
#+CATEGORY:   worg

{Back to Worg's index}

=element.ss= implements a parser according to Org's syntax
specification.

The library contains tools to generate an abstract syntax tree (AST)
from an Org buffer, to analyze the syntactical object at point.
Parsing functions are detailed in the first part of the document,
along with their relative accessors and setters.

Upon parsing, each token in an Org document gets a type and some
properties attached to it.  This information can be extracted and
modified with provided accessors and setters.  An exhaustive list of
all tyes and attributes is given in section #attributes.

Eventually, the library is packed with a few useful functions,
described in the last section of the document.

* INPROGRESS Descriptions 


Org's types are broken up as greater element, element and object.


Possible types are defined in `all-elements'.

#+NAME: element-descriptions
#+begin_src gerbil 
  (def all-elements
    '(babel-call center-block clock comment
      comment-block diary-sexp drawer dynamic-block example-block export-block
      fixed-width footnote-definition headline horizontal-rule inlinetask item keyword
      latex-environment node-property paragraph plain-list planning property-drawer
      quote-block section special-block src-block table table-row verse-block))

  (def (org-element? el) (and (pair? el) (memq (car el) all-elements) #t))

  (def greater-elements
    '(center-block drawer dynamic-block footnote-definition headline inlinetask
      item plain-list property-drawer quote-block section special-block table))

  (def (org-greater-element? el)
    (and (memq (if (symbol? el) el (car el)) greater-elements)  #t))

    (def all-objects
      '(bold code entity export-snippet footnote-reference inline-babel-call
    inline-src-block italic line-break latex-fragment link macro radio-target
    statistics-cookie strike-through subscript superscript table-cell target
    timestamp underline verbatim))

  (def object-restrictions

    ;;  Alist of objects restrictions.

    ;; key is an element or object type containing objects and value is
    ;; a list of types that can be contained within an element or object
    ;; of such type.

    ;; For example, in a `radio-target' object, one can only find
    ;; entities, latex-fragments, subscript, superscript and text
    ;; markup.

    ;; This alist also applies to secondary string.  For example, an
    ;; `headline' type element doesn't directly contain objects, but
    ;; still has an entry since one of its properties (`:title') does.

    (let* ((standard-set (remq 'table-cell all-objects))
           (standard-set-no-line-break (remq 'line-break standard-set)))
      `((bold ,@standard-set)
        (footnote-reference ,@standard-set)
        (headline ,@standard-set-no-line-break)
        (inlinetask ,@standard-set-no-line-break)
        (italic ,@standard-set)
        (item ,@standard-set-no-line-break)
        (keyword ,@(remq 'footnote-reference standard-set))
        ;; Ignore all links in a link description.  Also ignore
        ;; radio-targets and line breaks.
        (link bold code entity export-snippet inline-babel-call inline-src-block
              italic latex-fragment macro statistics-cookie strike-through
              subscript superscript underline verbatim)
        (paragraph ,@standard-set)
        ;; Remove any variable object from radio target as it would
        ;; prevent it from being properly recognized.
        (radio-target bold code entity italic latex-fragment strike-through
                      subscript superscript underline superscript)
        (strike-through ,@standard-set)
        (subscript ,@standard-set)
        (superscript ,@standard-set)
        ;; Ignore inline babel call and inline source block as formulas
        ;; are possible.  Also ignore line breaks and statistics
        ;; cookies.
        (table-cell bold code entity export-snippet footnote-reference italic
                    latex-fragment link macro radio-target strike-through
                    subscript superscript target timestamp underline verbatim)
        (table-row table-cell)
        (underline ,@standard-set)
        (verse-block ,@standard-set))))

  (def (org-element-restriction el)
    (cdr (assq (if (symbol? el) el (org-element-type el)) object-restrictions)))

#+end_src


* INPROGRESS ~plain-text~, not really an element.

Emacs has a way to give properties to text. We use strings, and while we could
create a ~(plain-text (raw-value [...]))~ element, that's a complication I'd
like to avoid.

#+NAME: plain-text
#+begin_src gerbil
  (def plain-text-properties-table (make-hash-table-eq weak-keys: #t))

  (def (plain-text-property prop plain-text)
    (pgetq prop (cadr (hash-ref plain-text-properties-table plain-text ['plain-text []]))))

  (def (plain-text-property-set! prop text value)
    (let (element (hash-ref plain-text-properties-table text #f))
      (begin0 text
      (if (not element)
        (hash-put! plain-text-properties-table text ['plain-text [prop value]])
        (set! (org-element-property prop element) value)))))
    
#+end_src

Easy! Now [[#accessors][Accessors]] can operate on strings.


* INPROGRESS Parsing functions
  :PROPERTIES:
  :CUSTOM_ID: parsing
  :END:

  There are two ways to parse a buffer using this library: either
  locally or globally.

  Local parsing gives information about the structure at point.
  Depending on the level of detail required, ~at-point~
  and ~context~ fullfill that role.

  Global parsing is done with ~parse-buffer~, which
  returns the AST representing the document.

** Analyzing the structure at point
   :PROPERTIES:
   :CUSTOM_ID: local
   :END:

   ~at-point~ offers a glimpse into the local structure of
   the document.  However, it stops at the element level.  It doesn't,
   for example, analyze the contents of a paragraph.  While this is
   sufficient for many use cases, ~context~ allows to go
   deeper, down to the object level.  The following example
   illustrates the difference between the two functions.

   #+name: context-vs-at-point
   #+BEGIN_SRC org
   ,*Lorem ipsum dolor* sit amet, consectetur adipisicing elit, sed do
   eiusmod tempor incididunt ut labore et dolore magna aliqua.
   #+END_SRC

   Indeed, calling ~at-point~ at the beginning of the
   paragraph returns a ~paragraph~ structure, whereas calling
   ~context~ returns a ~bold~ object.

   Unless point is on a headline, both functions indirectly return all
   parents of the value within the current section[fn:1], through
   ~:parent~ property.  For example, when point is at =(X)=

   #+name: full-hierarchy
   #+BEGIN_SRC org
   ,* Headline

     ,#+BEGIN_CENTER
     Paragraph(X)
     ,#+END_CENTER
   #+END_SRC

   ~at-point~ returns a ~paragraph~ element, whose
   ~:parent~ property contains a ~center-block~ element, which, in
   turn, has no ~:parent~ since the next ancestor is the section
   itself.

** INPROGRESS Creating a snapshot of the document
   :PROPERTIES:
   :CUSTOM_ID: global
   :header-args: :noweb-ref snapshot
   :END:

   ~parse-buffer~ completely parses a (possibly narrowed)
   buffer into an AST.  The virtual root node has type ~org-data~ and
   no properties attached to it.

   Unlike to local parsing functions, data obtained through
   ~parse-buffer~ can be altered to your heart's content.
   See #setters for a list of related tools.

[[file:~/.emacs.d/elpa/org-plus-contrib-20190408/org-element.el::(defun%20org-element--parse-elements][el --parse-elements]]

#+begin_src gerbil
  (def (parse-buffer str (granularity 'object))
    (run (parse-elements 0 (string-length str) 'first-section #f granularity ['org-data []])
         str))


  (def (parse-elements
        (beg 0) (end +inf.0) (mode #f) (structure #f)
        (granularity #f) (acc #f))
    (def elements [])

    (def (parse-greater-element-contents? el (type (org-element-type el)))
      ;;Make sure ~granularity~ allows the recursion, or
      ;; ~element~ is a headline, in which case going inside is
      ;; mandatory, in order to get sub-level headings.
      (and (org-greater-element? type)
           (or (memq granularity '(element object #f))
               (and (eq? granularity 'greater-element)
                    (eq? type 'section))
               (eq? type 'headline))))

    (.begin 
     (goto-char beg)
     (narrow-to-region beg end)
     ;; When parsing only headlines, skip any text before first one.
      (if (eq? granularity 'headline)
        (.begin (some SKIP-LINE) ORG-AT-HEADING)
        #f)
    ;;  ;; Find current element's type and parse it accordingly to
      ;;  ;; its category.
      (let parse-element ((el (parse-current-element granularity mode structure)))
        (.let*
         (el el)
         (push! elements el)
          (let ((type (org-element-type el))
          (cbeg (org-element-property contents-begin: el)))

      (cond
       ;; If element has no contents, don't modify it.
       ((not cbeg) (goto-char (org-element-property end: el)))
       ;; If we already have contents, just set the parent.
       ((org-element-contents el) =>
        (cut map
          (lambda (child) (set! (org-element-property parent: child) el)) <>))

       ;; Fill ~element contents by side-effect.
       ;; If element already has contents
       ;; Greater element: parse between contents-begin: and
       ;; contents-end:
       ((parse-greater-element-contents? type) #t)))
          ))
      (widen)
      (return elements)

      ))


  ;;; Parsing Element Starting At Point
  ;;
  ;; `parse-current-element' is the core function of this section. It returns the Gerbil
  ;; representation of the element starting at point.
  ;;
  ;; `parse-current-element' makes use of special modes. They are activated for fixed
  ;; element chaining (e.g., `plain-list' > `item') or fixed conditional element
  ;; chaining (e.g., `headline' > `section'). Special modes are: `first-section',
  ;; `item', `node-property', `section' and `table-row'.


  (def (parse-current-element (granularity #f) (mode #f) (structure #f))
    (def raw-secondary? (and granularity (not (eq? granularity 'object))))
    (.first
     (.or
      (headline-parser raw-secondary?)
      (.let*
       (afk (collect-affiliated-keywords))
       (.or (table-parser afk #f)
            (fail)))
         )))


  ;; Return either values of the string that comes before the object and the next
  ;; object, or #f. ~restriction~ is a list of object types, as symbols, that
  ;; should be looked after.

  (def (object-lex restriction)
    (.let* ((lst (some (item)))
            (obj (.or (and (memq 'timestamp restriction)
                           (timestamp-parser))
                      (.begin (sat (lambda _ (not (null? lst))) (.not (item))) #f))))
           (values (list->string lst) obj)))

  (def (parse-objects (beg 0) (end +inf.0) (acc #f) (restriction all-objects) (parent #f))
    (def (lexes->contents lexs)
      (def contents [])
        (let lp ((ls lexs))
          (unless (null? ls) 
            (let ((values str obj) (car ls))
              (unless (string-null? str) (push! str contents))
              (when obj
                (push! obj contents)
                (let ((obj-end (org-element-property end: obj))
                      (cont-beg (org-element-property contents-begin: obj)))
                    ;; Fill contents of ~object~ if needed
                    (when cont-beg
                      (parse-objects cont-beg (org-element-property contents-end: obj)
                                     obj (org-element-restriction obj)))))
                (lp (cdr ls)))))
     (reverse! contents))

    (.begin
     (narrow-to-region beg end)
     (goto-char beg)

     (.let*
      (cs ((liftP lexes->contents) (many (object-lex restriction))))


      (return cs))))

#+end_src

*** ~-next-node~

#+begin_src gerbil
  (def (next-mode type parent?)
    "Return next special mode according to TYPE, or #f.

  Modes can be either `first-section', `item', `node-property', `planning',
  `property-drawer', `section', `table-row' or #f."
    (if parent?
        (case type
          ((headline) 'section)
          ((inlinetask) 'planning)
          ((plain-list) 'item)
          ((property-drawer) 'node-property)
          ((section) 'planning)
          ((table) 'table-row)
          (else #f))
      (case type
        ((item) 'item)
        ((node-property) 'node-property)
        ((planning) 'property-drawer)
        ((table-row) 'table-row))))
#+end_src

* INPROGRESS Accessors
  :PROPERTIES:
  :CUSTOM_ID: accessors
  :header-args: :noweb-ref element-accessors
  :END:

  Type and properties of a given element or object are obtained with,
  respectively, ~org-element-type~ and ~org-element-property~.

  #+begin_src gerbil
    (def (org-element-type el) (if (string? el) 'plain-text (car el)))

    (def (org-element-property prop el)
      (if (string? el) (plain-text-property prop el)) (pgetq prop (cadr el)))
  #+end_src

  ~org-element-contents~ returns an ordered (by buffer position) list
  of all elements or objects within a given element or object.  Since
  local parsing ignores contents, it only makes sense to use this
  function on a part of an AST. 

 ~org-element-contents-set!~ sets the contents.

#+begin_src gerbil
  (def (org-element-contents el) 
    (let (c (cddr el)) (if (null? c) #f c)))

  (def (org-element-contents-set! el contents)
    (set-cdr! (cdr el) contents))

#+end_src

  Eventually, ~org-element-map~ operates on an AST, a part of it, or
  any list of elements or objects.  It is a versatile function.

  For example, it can be used to collect data from an AST.  Hence the
  following snippet returns all paragraphs beginning a section in the
  current document.  Note that equality between elements is tested
  with ~eq~.

  #+name: collect
  #+BEGIN_SRC emacs-lisp :noweb-ref collect
  (org-element-map (parse-buffer) 'paragraph
    (lambda (paragraph)
      (let ((parent (org-element-property :parent paragraph)))
        (and (eq (org-element-type parent) 'section)
             (let ((first-child (car (org-element-contents parent))))
               (eq first-child paragraph))
             ;; Return value.
             paragraph))))
  #+END_SRC

  It can also be used as a predicate.  Thus, the following snippet
  returns a non-nil value when the document contains a checked item.

  #+name: checkedp
  #+BEGIN_SRC emacs-lisp :noweb-ref checkedp
  (org-element-map (org-element-parse-buffer) 'item
    (lambda (item) (eq (org-element-property :checkbox item) 'on))
    nil t)
  #+END_SRC
  
  See ~org-element-map~'s docstring for more examples.

* Setters
  :PROPERTIES:
  :CUSTOM_ID: setters
  :header-args: :noweb-ref setters-code
  :END:

  ~org-element-property-set!~ (called ~org-element-put-property~ in Emacs)
   modifies any property of a given element or object.

  #+begin_src gerbil
    (def (org-element-property-set! prop el value)
      (def props (let lp ((ps (cadr el)))
                   (cond ((null? ps) [])
                         ((eq? prop (car ps))
                          (lp (cddr ps)))
                         (#t 
                          (cons* (first ps) (second ps) (lp (cddr ps)))))))
      (set-car! (cdr el) (cons* prop value props)))
  #+end_src

  Note that, even though structures obtained with local parsers are
  mutable, it is good practice to consider them immutable.  In
  particular, destructively changing properties relative to buffer
  positions is likely to break the caching mechanism running in the
  background.  If, for example, you need to slightly alter an element
  obtained using these functions, first copy it, using
  ~org-element-copy~, before modifying it by side effect.  There is no
  such restriction for elements grabbed from a complete AST.

  The library also provides tools to manipulate the parse tree.  Thus,
  ~org-element-extract-element~ removes an element or object from an
  AST, ~org-element-set-element~ replaces one with another, whereas
  ~org-element-insert-before~ and ~org-element-adopt-element~ insert
  elements within the tree, respectively before a precise location or
  after all children.

* Types and Attributes
  :PROPERTIES:
  :CUSTOM_ID: attributes
  :header-args: :noweb-ref object-parser
  :END:

  Each greater element, element and object has a variable set of
  properties attached to it.  Among them, four are shared by all
  types: ~begin:~ and ~end:~, which refer to the beginning and ending
  buffer positions of the considered element or object, ~:post-blank~,
  which holds the number of blank lines, or white spaces, at its
  end[fn:2] and ~:parent~, which refers to the element or object
  containing it.

  Greater elements containing objects on the one hand, and elements or
  objects containing objects on the other hand also have
  ~:contents-begin~ and ~:contents-end~ properties to delimit
  contents.
  
** Affiliated Keywords
   :PROPERTIES:
   :header-args: :noweb-ref affiliated-keywords
   :END:
  
  In addition to these properties, each element can optionally get
  some more from affiliated keywords, namely: ~caption:~, ~header:~,
  ~name:~, ~plot:~, ~results:~ or ~attr_NAME:~ where =NAME= stands for
  the name of an export back-end.


  Also, ~post-affiliated:~ property is attached to all elements.  It
  refers to the buffer position after any affiliated keyword, when
  applicable, or to the beginning of the element otherwise.

#+begin_src gerbil
  (defconst affiliated-keywords
    '("CAPTION" "DATA" "HEADER" "HEADERS" "LABEL" "NAME" "PLOT" "RESNAME" "RESULT"
      "RESULTS" "SOURCE" "SRCNAME" "TBLNAME"))

  ;; The key is the old name and the value the new one.")
  (defconst keyword-translation-alist
    '(("DATA" . "NAME")  ("LABEL" . "NAME") ("RESNAME" . "NAME")
      ("SOURCE" . "NAME") ("SRCNAME" . "NAME") ("TBLNAME" . "NAME")
      ("RESULT" . "RESULTS") ("HEADERS" . "HEADER")))

  ;;  Affiliated keywords can occur more than once in an element. By default, all
  ;;  keywords setting attributes (e.g., "ATTR_LATEX") allow multiple occurrences.
  (defconst multiple-keywords '("CAPTION" "HEADER"))

  ;; Affiliated keywords whose value can be parsed.
  (defconst parsed-keywords '("CAPTION"))

  ;; Affiliated keywords can have a secondary[value].
  (defconst dual-keywords '("CAPTION" "RESULTS"))
#+end_src


#+begin_src gerbil

  (def (collect-affiliated-keywords (limit +inf.0))
     ;; => /list/
    (def KEY (apply .any (map ci=? affiliated-keywords)))
    (def (afks (alist []))
      (.or 
       (.let*
        ( ;; make sure we're before the limit
         (_ (sat (cut < <> limit) (point)))
         ;; Find the afk
         (afk (AFFILIATED-KEYWORD KEY)))
        (let* ( ;; Take the keyword out of it
               (afkey (org-element-property key: afk))
               ;; Make sure we match the modern key
               (key (or (assget afkey keyword-translation-alist) afkey))
               ;; Now the value
               (val (org-element-property value: afk))
               ;; If we're parsed, parse!
               (restrict (org-element-restriction 'keyword))
               (parse? (member key parsed-keywords))
               (val (if parse?
                        (run (parse-objects 0 +inf.0 #f restrict) val)
                      val))
               ;; If ~key~ is a dual keyword, find its secondary value.
               (dual? (member key dual-keywords))
               (dual-val (and dual? (org-element-property option: afk)))
               ;;Maybe parse it.
               (dual-val
                (and dual-val
                     (if (not parse?) dual-val
                         (run (parse-objects 0 +inf.0 #f restrict) dual-val))))
               ;; And add it to the value
               (val (if (and dual? (or val dual-val)) (cons val dual-val) val))
               ;; Now, if this is one that can have many values, and one exists,
               ;; we'll cons it up.
               (val (if (or (member key multiple-keywords)
                            (string= key "ATTR_" 0 5))
                      (let (ac (assoc key alist))
                        (if (not ac) val (cons val (let (r (cdr ac))
                                                     (if (list? r) r (list r))))))
                      val))
               ;; name a new alist with this new key/val
               (new-alist (cons (cons key val) (alist-delete key alist))))
          ;; now call us again
          (afks new-alist)))

       (if (null? alist)
         (return #f)
         (return (append-map (lambda (ac) (list (string->keyword (string-downcase (car ac)))
                                     (cdr ac))) alist)))))

    (.let* ((b (point)) (lst (afks))) (if lst (cons b lst) [])))
#+end_src
 

** Position and Properties
  The following example illustrates the relationship between position
  properties.

  #+name: position-properties
  #+BEGIN_SRC org -n -r :noweb-ref position-properties
  ,#+NAME: dont-do-this-at-home (ref:begin)
  ,#+BEGIN_SRC emacs-lisp       (ref:post)
  (/ 1 0)
  ,#+END_SRC

  Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do (ref:end)
  eiusmod tempor incididunt ut labore et dolore magna aliqua.
  #+END_SRC

  The first element's type is ~src-block~.  Its ~begin:~ property
  (respectively ~end:~ property) is the buffer position at the
  beginning of line (begin) (respectively line (end)).
  ~post-affiliated:~ is the buffer position at the beginning of line
  (post).  Since source blocks cannot contain other elements or
  objects, both ~:contents-begin~ and ~:contents-end~ are
  nil. ~:post-blank~ is 1.

  Other properties, specific to each element or object type, are
  listed below.

** Babel Call

   Element.

   - ~:call~ :: Name of code block being called (string).
   - ~:inside-header~ :: Header arguments applied to the named code
        block (string or nil).
   - ~:arguments~ :: Arguments passed to the code block (string or
        nil).
   - ~:end-header~ :: Header arguments applied to the calling instance
        (string or nil).
   - ~:value~ :: Raw call, as Org syntax (string).

** Bold

   Recursive object.

   No specific property.

** Center Block

   Greater element.

   No specific property.

** Clock

   Element.

   - ~:duration~ :: Clock duration for a closed clock, or nil (string
                    or nil).
   - ~:status~ :: Status of current clock (symbol: ~closed~ or
                  ~running~).
   - ~:value~ :: Timestamp associated to clock keyword (timestamp
                 object).

** Code

   Object.

   - ~:value~ :: Contents (string).

** Comment

   Element.

   - ~:value~ :: Comments, with pound signs (string).

** Comment Block

   Element.

   - ~:value~ :: Comments, without block's boundaries (string).

** Diary Sexp

   Element.

   - ~:value~ :: Full Sexp (string).

** Drawer

   Greater element.

   - ~:drawer-name~ :: Drawer's name (string).

** Dynamic Block

   Greater element.

   - ~:arguments~ :: Block's parameters (string).
   - ~:block-name~ :: Block's name (string).
   - ~:drawer-name~ :: Drawer's name (string).

** Entity

   Object.

   - ~:ascii~ :: Entity's ASCII representation (string).
   - ~:html~ :: Entity's HTML representation (string).
   - ~:latex~ :: Entity's LaTeX representation (string).
   - ~:latex-math-p~ :: Non-nil if entity's LaTeX representation
        should be in math mode (boolean).
   - ~:latin1~ :: Entity's Latin-1 encoding representation (string).
   - ~:name~ :: Entity's name, without backslash nor brackets
                (string).
   - ~:use-brackets-p~ :: Non-nil if entity is written with optional
        brackets in original buffer (boolean).
   - ~:utf-8~ :: Entity's UTF-8 encoding representation (string).

** Example Block

   Element.

   - ~:label-fmt~ :: Format string used to write labels in current
                     block, if different from
                     ~org-coderef-label-format~ (string or nil).
   - ~:language~ :: Language of the code in the block, if specified
                    (string or nil).
   - ~:number-lines~ :: Non-nil if code lines should be numbered.
        A ~new~ value starts numbering from 1 wheareas ~continued~
        resume numbering from previous numbered block (symbol: ~new~,
        ~continued~ or nil).
   - ~:options~ :: Block's options located on the block's opening line
                   (string).
   - ~:parameters~ :: Optional header arguments (string or nil).
   - ~:preserve-indent~ :: Non-nil when indentation within the block
        mustn't be modified upon export (boolean).
   - ~:retain-labels~ :: Non-nil if labels should be kept visible upon
        export (boolean).
   - ~:switches~ :: Optional switches for code block export (string or
                    nil).
   - ~:use-labels~ :: Non-nil if links to labels contained in the
                      block should display the label instead of the
                      line number (boolean).
   - ~:value~ :: Contents (string).

** Export Block

   Element.

   - ~:type~ :: Related back-end's name (string).
   - ~:value~ :: Contents (string).

** Export Snippet

   Object.

   - ~:back-end~ :: Relative back-end's name (string).
   - ~:value~ :: Export code (string).

** Fixed Width

   Element.

   - ~:value~ :: Contents, without colons prefix (string).

** Footnote Definition

   Greater element.

   - ~:label~ :: Label used for references (string).
   - ~:pre-blank~ :: Number of newline characters between the
        beginning of the footnoote and the beginning of the contents
        (0, 1 or 2).

** Footnote Reference

   Recursive object.

   - ~:label~ :: Footnote's label, if any (string or nil).
   - ~:type~ :: Determine whether reference has its definition inline,
                or not (symbol: ~inline~, ~standard~).

** INPROGRESS Headline                                       :GreaterElement:
   :PROPERTIES:
   :header-args: :noweb-ref headline-element 
   :END:

   Greater element.

   In addition to the following list, any property specified in
   a property drawer attached to the headline will be accessible as an
   attribute (with an uppercase name, e.g. ~CUSTOM_ID:~).



   - ~archived?~ :: True if the headline has an archive tag
                     (boolean).
   - ~closed:~ :: Headline's CLOSED reference, if any (timestamp
                  object or #f)
   - ~commented?:~ :: #t if the headline has a comment keyword
                      (boolean).
   - ~deadline:~ :: Headline's DEADLINE reference, if any (timestamp
                    object or #f).
   - ~footnote-section?:~ ::  #t if the headline is a footnote section
                               (boolean).
   - ~level:~ :: Reduced level of the headline (integer).
   - ~pre-blank:~ :: Number of blank lines between the headline and
                     the first non-blank line of its contents
                     (integer).
   - ~priority:~ :: Headline's priority, as a character.
   - ~quoted?:~ :: #t if the headline contains a quote keyword
                   (boolean).
   - ~raw-value:~ :: Raw headline's text, without the stars and the
                     tags (string).
   - ~scheduled:~ :: Headline's SCHEDULED reference, if any (timestamp
                     object or nil).
   - ~tags:~ :: Headline's tags, if any, without the archive
                tag. (list of strings).
   - ~title:~ :: Parsed headline's text, without the stars and the
                 tags (secondary string).
   - ~todo-keyword:~ :: Headline's TODO keyword without quote and
        comment strings, if any (string or #f).
   - ~todo-type:~ :: Type of headline's TODO keyword, if any (symbol:
                     ~done~, ~todo~).

[[file:~/.emacs.d/elpa/org-plus-contrib-20190408/org-element.el::(defun%20org-element-headline-parser%20(limit%20&optional%20raw-secondary-p)][emacs lisp]]

#+begin_src gerbil 


  (def (headline-parser (raw-secondary? #f))
    (def NODE-PROPERTIES
      (.let* (pd PROPERTYDRAWER)
         (append-map!
          (lambda (np) [(string->keyword (string-upcase (org-element-property key: np)))
                   (org-element-property value: np)])
          (org-element-contents pd))))
    (.let*
     ((beg (point)) (h (HEADLINE))
      (stars (return (org-element-property stars: h)))
      (todo (return (org-element-property todo-keyword: h)))
      (raw-value (return (org-element-property title: h)))
      (title-end ((liftP 1-) (point)))
      (level (return (length stars)))
      (time-props (.or (PLANNING (timestamp-parser)) []))
      (standard-props []) ;(.or NODE-PROPERTIES []))
      (end (peek (.begin (org-end-of-subtree level))))
      (contents-begin (save-excursion
                       (goto-char title-end)
                       (skip-chars-forward " \n\r\t" end)
                       (beginning-of-line)))
      (pre-blank ((liftP 1-) (count-lines beg contents-begin)))
      (contents-end (save-excursion
                     (goto-char end)
                     (skip-chars-backward " \n\r\t")
                     (beginning-of-line 2)))
      (post-blank ((liftP 1-) (count-lines contents-end end))))

        (let (headline
              ['headline
               (append!
                (list
                 raw-value: raw-value
                 begin: beg end: end
                 pre-blank: pre-blank
                 contents-begin: contents-begin
                 contents-end: contents-end
                 level: level
                 priority: (org-element-property priority: h)
                 tags: (org-element-property tags: h)
                 todo-keyword: todo
                 todo-type: (if todo
                              (if (member todo (org-env-ref 'org-done-keywords))
                                'done 'todo)
                              #f)
                 post-blank: post-blank
                 footnote-section?: (org-element-property footnote-section?: h)
                 archived?: (org-element-property archived?: h)
                 commented?: (org-element-property commented?: h)
                 post-affiliated: beg)
                (append time-props standard-props))])
          (begin0 headline
            (set! (org-element-property title: headline)
              (if raw-secondary? raw-value
                  (run (parse-objects
                        0 +inf.0 #f (org-element-restriction 'headline)
                        headline) raw-value)))))))



#+end_src


** Horizontal Rule

   Element.

   No specific property.

** Inline Babel Call

   Object.

   - ~:call~ :: Name of code block being called (string).
   - ~:inside-header~ :: Header arguments applied to the named code
        block (string or nil).
   - ~:arguments~ :: Arguments passed to the code block (string or
        nil).
   - ~:end-header~ :: Header arguments applied to the calling instance
        (string or nil).
   - ~:value~ :: Raw call, as Org syntax (string).

** Inline Src Block

   Object.

   - ~:language~ :: Language of the code in the block (string).
   - ~:parameters~ :: Optional header arguments (string or nil).
   - ~:value~ :: Source code (string).

** Inlinetask

   Greater element.

   In addition to the following list, any property specified in
   a property drawer attached to the headline will be accessible as an
   attribute (with an uppercase name, e.g. ~:CUSTOM_ID~).

   - ~:closed~ :: Inlinetask's CLOSED reference, if any (timestamp
                  object or nil)
   - ~:deadline~ :: Inlinetask's DEADLINE reference, if any (timestamp
                    object or nil).
   - ~:level~ :: Reduced level of the inlinetask (integer).
   - ~:priority~ :: Headline's priority, as a character (integer).
   - ~:raw-value~ :: Raw inlinetask's text, without the stars and the
                     tags (string).
   - ~:scheduled~ :: Inlinetask's SCHEDULED reference, if any
                     (timestamp object or nil).
   - ~:tags~ :: Inlinetask's tags, if any (list of strings).
   - ~:title~ :: Parsed inlinetask's text, without the stars and the
                 tags (secondary string).
   - ~:todo-keyword~ :: Inlinetask's TODO keyword, if any (string or
        nil).
   - ~:todo-type~ :: Type of inlinetask's TODO keyword, if any
                     (symbol: ~done~, ~todo~).

** Italic

   Recursive object.

   No specific property.

** Item

   Greater element.

   - ~:bullet~ :: Item's bullet (string).
   - ~:checkbox~ :: Item's check-box, if any (symbol: ~on~, ~off~,
                    ~trans~, nil).
   - ~:counter~ :: Item's counter, if any.  Literal counters become
                   ordinals (integer).
   - ~:pre-blank~ :: Number of newline characters between the
        beginning of the item and the beginning of the contents (0,
        1 or 2).
   - ~:raw-tag~ :: Uninterpreted item's tag, if any (string or nil).
   - ~:tag~ :: Parsed item's tag, if any (secondary string or nil).
   - ~:structure~ :: Full list's structure, as returned by
                     ~org-list-struct~ (alist).

** Keyword

   Element.

   - ~:key~ :: Keyword's name (string).
   - ~:value~ :: Keyword's value (string).

** LaTeX Environment

   Element.

   - ~:begin~ :: Buffer position at first affiliated keyword or at the
                 beginning of the first line of environment (integer).
   - ~:end~ :: Buffer position at the first non-blank line after last
               line of the environment, or buffer's end (integer).
   - ~:post-blank~ :: Number of blank lines between last environment's
                      line and next non-blank line or buffer's end
                      (integer).
   - ~:value~ :: LaTeX code (string).

** LaTeX Fragment

   Object.

   - ~:value~ :: LaTeX code (string).

** Line Break

   Object.

   No specific property.

** Link

   Recursive object.

   - ~:application~ :: Name of application requested to open the link
                       in Emacs (string or nil). It only applies to
                       "file" type links.
   - ~:format~ :: Format for link syntax (symbol: ~plain~, ~angle~,
        ~bracket~).
   - ~:path~ :: Identifier for link's destination.  It is usually the
                link part with type, if specified, removed (string).
   - ~:raw-link~ :: Uninterpreted link part (string).
   - ~:search-option~ :: Additional information for file location
        (string or nil). It only applies to "file" type links.
   - ~:type~ :: Link's type.  Possible types (string) are:

     - ~coderef~ :: Line in some source code,
     - ~custom-id~ :: Specific headline's custom-id,
     - ~file~ :: External file,
     - ~fuzzy~ :: Target, referring to a target object, a named
                  element or a headline in the current parse tree,
     - ~id~ :: Specific headline's id,
     - ~radio~ :: Radio-target.

     It can also be any type defined in ~org-link-types~.

** Macro

   Object.

   - ~:args~ :: Arguments passed to the macro (list of strings).
   - ~:key~ :: Macro's name (string).
   - ~:value~ :: Replacement text (string).

** Node Property

   Element.

   - ~:key~ :: Property's name (string).
   - ~:value~ :: Property's value (string).

** INPROGRESS Paragraph

   Element containing objects.

   No specific property.
   Empty lines and other elements end paragraphs.

#+begin_src gerbil
  (def (paragraph-parser (afk []) values: (return-next-element-as-well #f)
                         granularity: (granularity #f))
    (def EMPTY-LINE (.begin (skip WS) (.or #\newline EOF)))
    (def END-PARAGRAPH
      (.or EMPTY-LINE (parse-current-element granularity 'no-paragraph #f)))

    (.let*
     ((beg (point))
            (lines (some SKIP-LINE))
            (lend (point))
            (end-el END-PARAGRAPH)
            (end (if (org-element? end-el)
                   (return end-el)
                   (.begin (skip-chars-forward " \n\r\t")
                           (point))))
            (post-blank (count-lines lend end)))
     (let (paragraph ['paragraph (cons* begin: (if (null? afk) beg (car afk))
                                        end: end
                                        contents-begin: beg
                                        contents-end:  (let (e (1- lend))
                                                         (if (< e end) lend e))
                                        post-blank: post-blank
                                        post-affiliated: beg
                                        afk)])
       (if return-next-element-as-well
         (values paragraph (if (org-element? end-el) end-el end-el))
         paragraph))))

#+end_src

** Plain List

   Greater element.

   - ~:structure~ :: Full list's structure, as returned by
                     ~org-list-struct~ (alist).
   - ~:type~ :: List's type (symbol: ~descriptive~, ~ordered~,
                ~unordered~).

** Planning

   Element.

   - ~:closed~ :: Timestamp associated to closed keyword, if any
                  (timestamp object or nil).
   - ~:deadline~ :: Timestamp associated to deadline keyword, if any
                    (timestamp object or nil).
   - ~:scheduled~ :: Timestamp associated to scheduled keyword, if any
                     (timestamp object or nil).

** Property Drawer

   Greater element.

   No specific property.

** Quote Block

   Greater element.

** Radio Target

   Recursive object.

   - ~:raw-value~ :: Uninterpreted contents (string).

** Section

   Greater element.

   No specific property.

** Special Block

   Greater element.

   - ~:type~ :: Block's name (string).
   - ~:raw-value~ :: Raw contents in block (string).

** Src Block

   Element.

   - ~:label-fmt~ :: Format string used to write labels in current
                     block, if different from
                     ~org-coderef-label-format~ (string or nil).
   - ~:language~ :: Language of the code in the block, if specified
                    (string or nil).
   - ~:number-lines~ :: Non-nil if code lines should be numbered.
        A ~new~ value starts numbering from 1 wheareas ~continued~
        resume numbering from previous numbered block (symbol: ~new~,
        ~continued~ or nil).
   - ~:parameters~ :: Optional header arguments (string or nil).
   - ~:preserve-indent~ :: Non-nil when indentation within the block
        mustn't be modified upon export (boolean).
   - ~:retain-labels~ :: Non-nil if labels should be kept visible upon
        export (boolean).
   - ~:switches~ :: Optional switches for code block export (string or
                    nil).
   - ~:use-labels~ :: Non-nil if links to labels contained in the
                      block should display the label instead of the
                      line number (boolean).
   - ~:value~ :: Source code (string).

** Statistics Cookie

   Object.

   - ~:value~ :: Full cookie (string).

** Strike Through

   Recursive object.

   No specific property.

** Subscript

   Recursive object.

   - ~:use-brackets-p~ :: Non-nil if contents are enclosed in curly
        brackets (t, nil).

** Superscript

   Recursive object.

   - ~:use-brackets-p~ :: Non-nil if contents are enclosed in curly
        brackets (t, nil).

** INPROGRESS Table
   :PROPERTIES:
   :END:

   Greater element.

   - ~tblfm:~ :: Formulas associated to the table, if any (string or
                 nil).
   - ~type:~ :: Table's origin (symbol: ~table.el~, ~org~).
   - ~value:~ :: Raw ~table.el~ table or nil (string or nil).

Basically, this table becomes the following when parsed in full.

#+NAME: this is a table
| N | N^2 | N^3 | N^4 | sqrt(n) | sqrt[4](N) |
|---+-----+-----+-----+---------+------------|
| / |   < |     |   > |       < |          > |
| 1 |   1 |   1 |   1 |       1 |          1 |
| 2 |   4 |   8 |  16 |  1.4142 |     1.1892 |
| 3 |   9 |  27 |  81 |  1.7321 |     1.3161 |
|---+-----+-----+-----+---------+------------|
#+TBLFM: $2=$1^2::$3=$1^3::$4=$1^4::$5=sqrt($1)::$6=sqrt(sqrt(($1)))


#+begin_src emacs-lisp :results code
  ;; Emacs Lisp
  (set-buffer "element.org")
  (org-element-map (org-element-parse-buffer) '(table) 
    (lambda (tbl)
      (org-element-put-property tbl :parent '())
      (list (car tbl) (cadr tbl)))
    nil t)
#+end_src

#+begin_src emacs-lisp
(table
 (:begin 35374 :end 35798 :type org :tblfm
         ("$2=$1^2::$3=$1^3::$4=$1^4::$5=sqrt($1)::$6=sqrt(sqrt(($1)))")
         :contents-begin 35398 :contents-end 35727 :value nil :post-blank 2 :post-affiliated 35398 
         :name "this is a table" :parent nil))
#+end_src

#+NAME: table-parser
#+begin_src gerbil
  (def (table-parser (affiliated []) (table-row #f))
    ;; ~affiliated~ is a list of which ~car~ is the buffer position at the
    ;; beginning of the first affiliated keyword and ~cdr~ is a plist of
    ;; affiliated keywords along with their value.

    ;; If ~table-row~ is a parser, use that and return contents. This saves time
    ;; and effort for big tables when we actually want the lines.

    ;; A | followed by anything that is not WS marks a table line

    (def TABLE-LINE
      (.begin (skip WS) #\| (skip WS) (sat (? (not char-whitespace?))) SKIP-LINE))

    (.let* ((b (if (not (null? affiliated)) (return (car affiliated)) (point)))
            (table-begin (point))
            (contents (many1 (or table-row TABLE-LINE)))
            (table-end (point))
            (tblfm (.or (many1 TBLFM) #f))
            (pos-before-blank (point))
            (blanks (many (.begin (many WS) #\newline)))
            (end (point))
            (afks (return (if (pair? affiliated) (cdr affiliated) [])))
            (contents (return (if table-row contents []))))
    ['table [begin: b end: end type: 'org tblfm: tblfm
             contents-begin: table-begin contents-end: table-end
             value: #f post-blank: (length blanks)
             post-affiliated: table-begin
             . afks]
            . contents]))
#+end_src



   |   |

   | asd | asd |
   |-----+-----|
   |     |     |


   


   
*** Interpret data  

To write a table is very simple. 

#+begin_src gerbil
  (import :std/iter)
  (def (table-intepreter table)
    (let ((rows (org-element-contents table)))
      (with-output-to-string
        ""
        (cut for (row rows)
             (let (type (org-element-property type: row))
               (display #\|)
               (let dcs ((cells (org-element-contents row)))
                 (unless (null? cells)
                   (let (cell (car cells))
                     (display (org-element-contents cell))
                     (case type
                       ((standard) (map display (org-element-property spaces: cell) [])
                        (display #\|))
                       ((rule) (display (if (null? (cdr cells)) #\| #\+)))))
                   (dcs (cdr cells)))))
             (display #\newline)))))



#+end_src

   

  

  


** Table Cell

   Recursive object.

   No specific property.

** Table Row

   Element containing objects.

   - ~:type~ :: Row's type (symbol: ~standard~, ~rule~).

** Target

   Object.

   - ~:value~ :: Target's ID (string).

** INPROGRESS Timestamp                                              :Object:
   :PROPERTIES:
   :header-args: :noweb-ref timestamp-element
   :END:

   Object.

   - ~day-end:~ :: Day part from timestamp end.  If no ending date is
                   defined, it defaults to start day part (integer).
   - ~day-start:~ :: Day part from timestamp start (integer).
   - ~hour-start:~ :: Hour part from timestamp end. If no ending date
                      is defined, it defaults to start hour part, if
                      any (integer or #f).
   - ~hour-start:~ :: Hour part from timestamp start, if specified
                      (integer or #f).
   - ~minute-start:~ :: Minute part from timestamp end. If no ending
        date is defined, it defaults to start minute part, if any
        (integer or #f).
   - ~minute-start:~ :: Minute part from timestamp start, if specified
        (integer or #f).
   - ~month-end:~ :: Month part from timestamp end.  If no ending date
                     is defined, it defaults to start month part
                     (integer).
   - ~month-start:~ :: Month part from timestamp start (integer).
   - ~raw-value:~ :: Raw timestamp (string).
   - ~repeater-type:~ :: Type of repeater, if any (symbol: ~catch-up~,
        ~restart~, ~cumulate~ or #f)
   - ~repeater-unit:~ :: Unit of shift, if a repeater is defined
        (symbol: ~year~, ~month~, ~week~, ~day~, ~hour~ or #f).
   - ~repeater-value:~ :: Value of shift, if a repeater is defined
        (integer or #f).
   - ~type:~ :: Type of timestamp (symbol: ~active~, ~active-range~,
                ~diary~, ~inactive~, ~inactive-range~).
   - ~warning-type:~ :: Type of warning, if any (symbol: ~all~,
        ~first~ or #f)
   - ~warning-unit:~ :: Unit of delay, if one is defined (symbol:
        ~year~, ~month~, ~week~, ~day~, ~hour~ or #f).
   - ~warning-value:~ :: Value of delay, if one is defined (integer or
        #f).
   - ~year-end:~ :: Year part from timestamp end.  If no ending date
                    is defined, it defaults to start year part
                    (integer).
   - ~year-start:~ :: Year part from timestamp start (integer).

#+begin_src gerbil
  (def (timestamp-parser)
    (def (stamp-type stamp)
      (let* ((start (org-element-property start: stamp))
             (name (if (char=? start #\<) "active" "inactive"))
             (range (org-element-property range: stamp))
             (ts (org-element-property inner: stamp))
             (name (if (or range (org-element-property end: ts))
                     (string-append name "-range") name)))
        (string->symbol name)))
    (def (repeater/warning-type r)
     ;; MARK is ~+~ (cumulate type), ~++~ (catch-up type) or ~.+~ (restart type)
     ;; for a repeater, and ~-~ (all type) or ~--~ (first type) for warning
     ;; delays.
      (case (string->symbol (org-element-property m: r))
        ((+) 'cumulate) ((++) 'catch-up) ((.+) 'restart)
        ((-) 'all) ((--) 'first)))

    (def (warning? r)
      (and r (member (repeater/warning-type r) '(all first))))
    (def (repeater? r)
      (and r (not (warning? r))))

    (def (rep/warn-props r)
      (def name (if (warning? r) "warning-" "repeater-"))
      (def (key n) (string->keyword (string-append name n)))

      (if (not r) []
          (list (key "type") (repeater/warning-type r)
                ;; UNIT is a character among ~h~ (hour), ~d~ (day), ~w~ (week),
                ;; ~m~ (month), ~y~ (year).
                (key "unit") (case (string->symbol
                                    (string (org-element-property u: r)))
                               ((h) 'hour) ((d) 'day) ((w) 'week)
                               ((m) 'month) ((y) 'year))
                (key "value") (org-element-property v: r))))


    (.let* ((b (point)) (stamp TIMESTAMP) (e (point))
            (raw-value (buffer-substring b e)))
     (let* ((ts (org-element-property inner: stamp))
            (type (stamp-type stamp))
            (sd (org-element-property date: ts))
            (ys (org-element-property y: sd))
            (mos (org-element-property m: sd)) 
            (ds (org-element-property d: sd)) 
            (st (org-element-property start: ts)) 
            (hs (and st (org-element-property h: st)))
            (mis (and st (org-element-property m: st)))
            (range (org-element-property range: stamp))
            (rts (and range (org-element-property inner: range)))
            (et (or (and rts (org-element-property start: rts))
                    (org-element-property end: ts)
                    st))         
            (range (if rts (org-element-property date: rts) sd))
            (ye (org-element-property y: range)) 
            (moe (org-element-property m: range))
            (de (org-element-property d: range))
            (he (and et (org-element-property h: et)))
            (mie (and et (org-element-property m: et)))
            (rep/warn (list  (org-element-property repeat: ts)
                              (org-element-property warn: ts)
                              (and rts (org-element-property repeat: rts))
                              (and rts (org-element-property warn: rts))))
            (repeater (find repeater? rep/warn))
            (warning (find warning? rep/warn))
            (r/w-props (append (rep/warn-props repeater)
                               (rep/warn-props warning))))
       ['timestamp  (cons* type: type raw-value: raw-value
                          year-start: ys month-start: mos day-start: ds
                          hour-start: hs minute-start: mis

                          year-end: ye month-end: moe day-end: de
                          hour-end: he minute-end: mie
                          begin: b end: e post-blank: 0

                          r/w-props)])))








#+end_src

** Underline

   Recursive object.

   No specific property.

** Verbatim

   Object.

   - ~:value~ :: Contents (string).

** Verse Block

   Element containing objects.

   No specific property.

* Other Tools
  :PROPERTIES:
  :CUSTOM_ID:       other-tools
  :END:

** Turning an AST into an Org document

   ~interpret-data~ is the reciprocal operation of
   ~parse-buffer~.  When provided an element, object, or
   even a full parse tree, it generates an equivalent string in Org
   syntax.

   More precisely, output is a normalized document: it preserves
   structure and blank spaces but it removes indentation and
   capitalize keywords.  As a consequence it is equivalent, but not
   equal, to the original document the AST comes from.

   When called on an element or object obtained through
   ~at-point~ or ~context~, its contents will
   not appear, since this information is not available.



** Examining genealogy of an element or object

   ~org-element-lineage~ produces a list of all ancestors of a given
   element or object.  However, when these come from a local parsing
   function, lineage is limited to the section containing them.

   With optional arguments, it is also possible to check for
   a particular type of ancestor.  See function's docstring for more
   information.


* /file/ element.ss

#+begin_src gerbil :noweb yes :tangle element.ss
  ;; (c) drewc <me@drewc.ca> All Rights Reserved
  (import :drewc/smug 
          :drewc/org/syntax :drewc/org/environment :drewc/org/location
          :std/srfi/13 :std/srfi/1 :gerbil/gambit/exact :std/misc/list)
  (export #t)

  <<element-descriptions>>

  <<plain-text>>

  <<element-accessors>>

  <<setters-code>>


  ;; * Affiliated Keywords

  ;; Each element can optionally get some more from affiliated keywords, namely:
  ;; ~caption:~, ~header:~, ~name:~, ~plot:~, ~results:~ or ~attr_NAME:~ where
  ;; =NAME= stands for the name of an export back-end.

  <<affiliated-keywords>>

  <<table-parser>>

  <<timestamp-element>>

  <<headline-element>>

  <<snapshot>>
#+end_src
* Copyright

Documentation from the orgmode.org/worg/ website (either in its HTML format or
in its Org format) is licensed under the GNU Free Documentation License version
1.3 or later

Copyright (C) 2019 Drew Crampsie.
    Permission is granted to copy, distribute and/or modify this document
    under the terms of the GNU Free Documentation License, Version 1.3
    or any later version published by the Free Software Foundation;
    with no Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts.
    A copy of the license is included in the section entitled "GNU
    Free Documentation License".


** History 

#+begin_src org
#+end_src

* Footnotes

[fn:1] Thus, ~at-point~ cannot return the parent of
a headline.  Nevertheless, headlines are context free elements: it is
efficient to move to parent headline (e.g., with
~org-up-heading-safe~) before analyzing it.

[fn:2] As a consequence whitespaces or newlines after an element or
object still belong to it.  To put it differently, ~:end~ property of
an element matches ~:begin~ property of the following one at the same
level, if any.
