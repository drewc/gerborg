#+TITLE:      Org Element API
#+AUTHOR:     Nicolas Goaziou
#+EMAIL:      mail@nicolasgoaziou.fr
#+STARTUP:    align fold nodlcheck hidestars oddeven lognotestate
#+SEQ_TODO:   TODO(t) INPROGRESS(i) WAITING(w@) | DONE(d) CANCELED(c@)
#+TAGS:       Write(w) Update(u) Fix(f) Check(c) NEW(n) Object(o) Element(e) GreaterElement(g) RecursiveObject(r)
#+LANGUAGE:   en
#+PRIORITIES: A C B
#+CATEGORY:   worg

=element.ss= implements a parser according to Org's syntax
specification.

The library contains tools to generate an abstract syntax tree (AST)
from an Org buffer, to analyze the syntactical object at point.
Parsing functions are detailed in the first part of the document,
along with their relative accessors and setters.

Upon parsing, each token in an Org document gets a type and some
properties attached to it.  This information can be extracted and
modified with provided accessors and setters.  An exhaustive list of
all tyes and attributes is given in section #attributes.

Eventually, the library is packed with a few useful functions,
described in the last section of the document.

* INPROGRESS COMMENT Descriptions 


Org's types are broken up as greater element, element and object.


Possible types are defined in `all-elements'.

#+NAME: element-descriptions
#+begin_src gerbil 
  (def all-elements
    '(babel-call center-block clock comment
      comment-block diary-sexp drawer dynamic-block example-block export-block
      fixed-width footnote-definition headline horizontal-rule inlinetask item keyword
      latex-environment node-property paragraph plain-list planning property-drawer
      quote-block section special-block src-block table table-row verse-block))

  (def (org-element-element? el) (and (pair? el) (memq (car el) all-elements) #t))

  (def greater-elements
    '(center-block drawer dynamic-block footnote-definition headline inlinetask
      item plain-list property-drawer quote-block section special-block table))

  (def (org-element-greater-element? el)
    (and (memq (if (symbol? el) el (car el)) greater-elements)  #t))


  (def all-objects
      '(bold code entity export-snippet footnote-reference inline-babel-call
    inline-src-block italic line-break latex-fragment link macro radio-target
    statistics-cookie strike-through subscript superscript table-cell target
    timestamp underline verbatim))

  (def (org-element-object? el) (and (pair? el) (memq (car el) all-objects) #t))

  (def org-element? (? (or org-element-element? org-element-object?)))

  (def object-restrictions

    ;;  Alist of objects restrictions.

    ;; key is an element or object type containing objects and value is
    ;; a list of types that can be contained within an element or object
    ;; of such type.

    ;; For example, in a `radio-target' object, one can only find
    ;; entities, latex-fragments, subscript, superscript and text
    ;; markup.

    ;; This alist also applies to secondary string.  For example, an
    ;; `headline' type element doesn't directly contain objects, but
    ;; still has an entry since one of its properties (`:title') does.

    (let* ((standard-set (remq 'table-cell all-objects))
           (standard-set-no-line-break (remq 'line-break standard-set)))
      `((bold ,@standard-set)
        (footnote-reference ,@standard-set)
        (headline ,@standard-set-no-line-break)
        (inlinetask ,@standard-set-no-line-break)
        (italic ,@standard-set)
        (item ,@standard-set-no-line-break)
        (keyword ,@(remq 'footnote-reference standard-set))
        ;; Ignore all links in a link description.  Also ignore
        ;; radio-targets and line breaks.
        (link bold code entity export-snippet inline-babel-call inline-src-block
              italic latex-fragment macro statistics-cookie strike-through
              subscript superscript underline verbatim)
        (paragraph ,@standard-set)
        ;; Remove any variable object from radio target as it would
        ;; prevent it from being properly recognized.
        (radio-target bold code entity italic latex-fragment strike-through
                      subscript superscript underline superscript)
        (strike-through ,@standard-set)
        (subscript ,@standard-set)
        (superscript ,@standard-set)
        ;; Ignore inline babel call and inline source block as formulas
        ;; are possible.  Also ignore line breaks and statistics
        ;; cookies.
        (table-cell bold code entity export-snippet footnote-reference italic
                    latex-fragment link macro radio-target strike-through
                    subscript superscript target timestamp underline verbatim)
        (table-row table-cell)
        (underline ,@standard-set)
        (verse-block ,@standard-set))))

  (def (org-element-object-restrictions el)
    (cdr (assq (if (symbol? el) el (org-element-type el)) object-restrictions)))

   ;; "List of recursive object types."

  (def recursive-objects
   '(bold footnote-reference italic link subscript radio-target strike-through
     superscript table-cell underline))

  (def (org-element-recursive-object? el)
    (and (memq (if (symbol? el) el (car el)) recursive-objects)  #t))

  (def secondary-value-alist
    '((headline title:)
      (inlinetask title:)
      (item tag:)))

  (def (org-element-secondary-value el)
    (let (key (assgetq (org-element-type el) secondary-value-alist))
      (and key (org-element-property key el))))

  (def parsed-properties-alist
    '(("CAPTION" . caption:)))


#+end_src


* INPROGRESS ~plain-text~, not really an element.

Emacs has a way to give properties to text. We use strings, and while we could
create a ~(plain-text (raw-value [...]))~ element, that's a complication I'd
like to avoid.

#+NAME: plain-text
#+begin_src gerbil
  (def plain-text-properties-table (make-hash-table-eq weak-keys: #t))

  (def (plain-text-property prop plain-text)
    (pgetq prop (cadr (hash-ref plain-text-properties-table plain-text ['plain-text []]))))

  (def (plain-text-property-set! prop text value)
    (let (element (hash-ref plain-text-properties-table text #f))
      (begin0 text
      (if (not element)
        (hash-put! plain-text-properties-table text ['plain-text [prop value]])
        (set! (org-element-property prop element) value)))))

#+end_src

Easy! Now [[#accessors][Accessors]] can operate on strings.


* INPROGRESS Parsing functions
  :PROPERTIES:
  :CUSTOM_ID: parsing
  :END:

  There are two ways to parse a buffer using this library: either
  locally or globally.

  Local parsing gives information about the structure at point.
  Depending on the level of detail required, ~at-point~
  and ~context~ fullfill that role.

  Global parsing is done with ~parse-buffer~, which
  returns the AST representing the document.

** Analyzing the structure at point
   :PROPERTIES:
   :CUSTOM_ID: local
   :END:

   ~at-point~ offers a glimpse into the local structure of
   the document.  However, it stops at the element level.  It doesn't,
   for example, analyze the contents of a paragraph.  While this is
   sufficient for many use cases, ~context~ allows to go
   deeper, down to the object level.  The following example
   illustrates the difference between the two functions.

   #+name: context-vs-at-point
   #+BEGIN_SRC org
   ,*Lorem ipsum dolor* sit amet, consectetur adipisicing elit, sed do
   eiusmod tempor incididunt ut labore et dolore magna aliqua.
   #+END_SRC

   Indeed, calling ~at-point~ at the beginning of the
   paragraph returns a ~paragraph~ structure, whereas calling
   ~context~ returns a ~bold~ object.

   Unless point is on a headline, both functions indirectly return all
   parents of the value within the current section[fn:1], through
   ~:parent~ property.  For example, when point is at =(X)=

   #+name: full-hierarchy
   #+BEGIN_SRC org
   ,* Headline

     ,#+BEGIN_CENTER
     Paragraph(X)
     ,#+END_CENTER
   #+END_SRC

   ~at-point~ returns a ~paragraph~ element, whose
   ~:parent~ property contains a ~center-block~ element, which, in
   turn, has no ~:parent~ since the next ancestor is the section
   itself.

** INPROGRESS Creating a snapshot of the document
   :PROPERTIES:
   :CUSTOM_ID: global
   :header-args: :noweb-ref snapshot
   :END:

   ~parse-buffer~ completely parses a (possibly narrowed)
   buffer into an AST.  The virtual root node has type ~org-data~ and
   no properties attached to it.

   Unlike to local parsing functions, data obtained through
   ~parse-buffer~ can be altered to your heart's content.
   See #setters for a list of related tools.

*** /Function/ ~parse-buffer~


 #+begin_src gerbil
   (def (parse-buffer str (granularity 'object))
     (run (parse-elements 0 (string-length str) 'first-section #f granularity ['org-data []])
          str))
 #+end_src

*** INPROGRESS /Parser/ ~parse-elements b e m s g a#~ 
 #+begin_src gerbil

   (defsyntax (nest stx)
     (syntax-case stx ()
       ((_ outer ... inner)
        (foldr (lambda (outer-form inner-form)
                 (with-syntax (((o ...) outer-form)
                               (i inner-form))
                   #'(o ... i)))
               #'inner
               #'(outer ...)))))

   (def (parse-elements
         (beg 0) (end +inf.0) (mode #f) (structure #f)
         (granularity #f) (acc #f))

     (def (parse-greater-element-contents? el (type (org-element-type el)))
       ;;Make sure ~granularity~ allows the recursion, or
       ;; ~element~ is a headline, in which case going inside is
       ;; mandatory, in order to get sub-level headings.
       (and (org-element-greater-element? el)
            (or (memq granularity '(element object #f))
                (and (eq? granularity 'greater-element)
                     (eq? type 'section))
                (eq? type 'headline))))
     (.begin
       (goto-char beg)
       (narrow-to-region beg end)
       ;; When parsing only headlines, skip any text before first one.
       (if (eq? granularity 'headline)
         (.begin (some SKIP-LINE) ORG-AT-HEADING)
         #f)
       ;;  ;; Find current element's type and parse it accordingly to
       ;;  ;; its category.
       (.let*
           (els
            (nest
             (let ((elements [])
                   (next-element (parse-current-element granularity mode structure))))
             (let parse-element ((p next-element))
               (nest (.let* (el (.or p #f)))
                     (if (not el) (return (reverse! elements)))
                     (let* ((next next-element)
                            ;; Paragraph return VALUES
                            (el (if (org-element? el) el
                                    (match el ((values nel n)
                                               (when n (set! next (return n)))
                                               nel))))
                            (type (org-element-type el))
                            (cbeg (org-element-property contents-begin: el))
                            (cend (org-element-property contents-end: el)))
                       (displayln el)
                       (push! el elements))
                     (.let* (contents 
                             (cond
                              ;; If element has no contents, don't modify it.
                              ((not cbeg) #f)
                              ;; ;; If we already have contents, We're almost done.
                              ((org-element-contents el) => (cut return <>))

                              ;; Fill ~element~ contents by side-effect. Greater
                              ;; element: parse between contents-begin: and
                              ;; contents-end:
                              ((parse-greater-element-contents? el)
                               (.begin (parse-elements
                                        cbeg cend ;; Possibly switch to a special mode.
                                        (next-mode type #t)
                                        (and (memq type '(item plain-list))
                                             (org-element-property structure: el))
                                        granularity el)
                                       (return (org-element-contents el))))

                              ;; It's an element or object that has contents, which
                              ;; are objects. So, parse them if allowed.
                              ((memq granularity '(object #f))
                               (displayln "Parsing objects " cbeg "-" cend " for " type)
                               (parse-objects cbeg cend el
                                              (org-element-object-restrictions el)))
                              (#t (return #f))))
                        ;; (when contents
                        ;;   (for (child contents)
                            ;(set! (org-element-property parent: child) el)))
                       (.begin (goto-char (org-element-property end: el))
                               (parse-element next)))))))
         (.begin (widen)
                 (if (not acc) (return els)
                     (begin0 (return acc) (set! (org-element-contents acc) els)))))))

 #+end_src

*** INPROGRESS /Parser/ ~parse-current-element~

 Parsing Element Starting At Point

  ~parse-current-element~ is the core function of this section. It returns the
  Gerbil representation of the element starting at point, or #f if there is no element.

  GRANULARITY determines the depth of the recursion. Allowed values are
  ~headline~, ~greater-element~, ~element~, ~object~ or ~#f~. When it is broader
  than ~object~ (or ~#f~), secondary values will not be parsed, since they only
  contain objects.

  ~parse-current-element~ makes use of special modes.


   They are activated parsing the contents of elements.
   - ~section~ :: Will parse a section.
   - ~end-at-heading~ :: When at a heading,  return ~#f~
   - ~(end-of-subtree n)~ :: For headlines. 
   - ~no-paragraph~ :: parsing for any element but paragraphs
        



#+begin_src gerbil
  (def (parse-current-element (granularity #f) (mode #f) (structure #f))
    "=> ~element~ /or/ #f"
    (def raw-secondary? (and granularity (not (eq? granularity 'object))))
    (.first
     (.begin
       (.let* (p (point)) (displayln "parse-current-element g:" granularity
                                     " M: " mode " at " p "\n") #f)
       ;; Now for predication.
       (cond
        ;; This is for headlines
        ((and (pair? mode) (eq? (car mode) 'end-of-subtree))
         (.not (org-end-of-subtree (cadr mode))))
        ;; Paragraphs and sections
        ((memq mode '(no-paragraph section end-at-heading)) (.not ORG-AT-HEADING))
        ;; For all else, just pass anything.
        (#t (return #t)))

       ;;; Specific element modes
       (cond
        ((eq? mode 'section) (section-parser granularity))

        ;; Otherwise, Giv'r! 
        (#t 

         (.or
           ;; (if (not (eq? mode 'table-row)) (fail)
           ;;     (table-row-parser granularity))
           (headline-parser raw-secondary?)
           (.let* (afk (collect-affiliated-keywords))
             (.or (table-parser afk granularity)
                  (if (eq? mode 'no-paragraph) (fail)
                      (paragraph-parser))))))))))
#+end_src

**** INPROGRESS Usage 

     #+begin_src gerbil :noweb-ref parse-current-element-test
       (def parse-current-element-test
         (test-suite
          "Testing parse-current-element"
          (test-case
           "end-at-heading"
           (def testb "This is a paragraph
       ,#+name: now a table
       |asd|asd|

       ,* and this should end it")
           (def el (run (parse-elements 0 1024 'end-at-heading #f #f ['org-doc []]) testb))

           (def contents (org-element-contents el))
           (check-equal? 2 (length contents))
           (check-eq? (org-element-type (list-ref contents 0)) 'paragraph))

          (def els (run (parse-elements 0 1024 #f #f #f ['org-doc []]) testb))

          (def contentss (org-element-contents els))
          (check-equal? 3 (length contentss))
          (check-eq? (org-element-type (list-ref contentss 2)) 'headline)))

     #+end_src


*** INPROGRESS /Parser/ ~parse-objects~

#+begin_src gerbil
    ;; Return either values of the string that comes before the object and the next
    ;; object, or #f. ~restriction~ is a list of object types, as symbols, that
    ;; should be looked after.

  (def (object-lex restrictions)
    (def (obj? name parser)
      (if (not (memq name restrictions)) (fail)
          parser))

    (def lex-objs
      (.or (obj? 'code (code-parser))
           (obj? 'bold (bold-parser))
           (obj? 'italic (italic-parser))
           (obj? 'verbatim (verbatim-parser))
           (obj? 'strike-through (strike-through-parser))
           (obj? 'timestamp (timestamp-parser))
           (obj? 'table-cell (table-cell-parser))
           (obj? 'table-cell-rule (table-cell-parser 'rule))))

      (.let* ((lst (some (item)))
              (obj (.or lex-objs
                        ;; if the list is not null, but we're at the end of the
                        ;; line, return #f for the object
                        (.begin (sat (lambda _ (not (null? lst))) (.not (item))) #f))))
             (values (list->string lst) obj)))

  (def (parse-objects (beg 0) (end +inf.0) (acc #f) (restriction all-objects) (parent #f))
    (def (lexes->contents lexs)
      (def contents [])
      (let lp ((ls lexs))
        (if (null? ls) (return (reverse! contents))
          (let ((values str obj) (car ls))
            (unless (string-null? str) (push! str contents))
            (cond
             ((not obj) (lp (cdr ls)))
             (#t  
              (push! obj contents)
              (let ((obj-end (org-element-property end: obj))
                    (cont-beg (org-element-property contents-begin: obj)))
                ;; Fill contents of ~object~ if needed
                  (.begin
                    (if (and (org-element-recursive-object? obj)
                             cont-beg)
                      (parse-objects cont-beg (org-element-property contents-end: obj)
                                     obj (org-element-object-restrictions obj))
                      #t)
                    (lp (cdr ls))))))))))

    (.begin
      (narrow-to-region beg end)
      (goto-char beg)
      (.let* ((lexes (many (object-lex restriction)))
              (cs (lexes->contents lexes))
              (_ (widen)))
        (when parent
          (for (el cs) (when (not (string? el))
                         (set! (org-element-property parent: el) parent))))
        ;;  If there's truly an element to give our contents to, giv'r!
        (if acc
          (begin0 (return acc)
            (org-element-contents-set! acc cs))
          (return cs)))))
#+end_src


*** /function/ ~next-node~

#+begin_src gerbil
  (def (next-mode type parent?)
    "Return next special mode according to TYPE, or #f.

  Modes can be either `first-section', `item', `node-property', `planning',
  `property-drawer', `section', `table-row' or #f."
    (if parent?
        (case type
          ((headline) 'section)
          ((inlinetask) 'planning)
          ((plain-list) 'item)
          ((property-drawer) 'node-property)
          ((section) 'planning)
          ((table) 'table-row)
          (else #f))
      (case type
        ((item) 'item)
        ((node-property) 'node-property)
        ((planning) 'property-drawer)
        ((table-row) 'table-row))))
#+end_src

* INPROGRESS Accessors
  :PROPERTIES:
  :CUSTOM_ID: accessors
  :header-args: :noweb-ref element-accessors
  :END:

  Type and properties of a given element or object are obtained with,
  respectively, ~org-element-type~ and ~org-element-property~.

  #+begin_src gerbil
    (def (org-element-type el)
      (cond ((string? el) 'plain-text) ((org-element? el) (car el)) (#t #f)))

    (def (org-element-property prop el)
      (if (string? el) (plain-text-property prop el)) (pgetq prop (cadr el)))
  #+end_src

  ~org-element-contents~ returns an ordered (by buffer position) list
  of all elements or objects within a given element or object.  Since
  local parsing ignores contents, it only makes sense to use this
  function on a part of an AST. 

 ~org-element-contents-set!~ sets the contents and returns the element.

#+begin_src gerbil
  (def (org-element-contents el) 
    (let (c (if (string? el) [] (cddr el))) (if (null? c) #f c)))

  (def (org-element-contents-set! el contents)
    (for (c contents) (set! (org-element-property parent: c) el))
    (begin0 el (set-cdr! (cdr el) contents)))

#+end_src

  Eventually, ~org-element-map~ operates on an AST, a part of it, or
  any list of elements or objects.  It is a versatile function.

#+begin_src gerbil
  (def (org-element-map data types fn
                        info: (info '())
                        first-match: (first? #f)
                        no-recursion: (no-recursions '())
                        with-affiliated: (with-affiliated? #t))
    ;; Should we map this element?
    (def (map-type? type) (or (eq? types #t) (memq type types)))

    (def (granularity)
      (let/cc found
        (let ((gran 'greater-elements)
              (all-objects (cons 'plain-text all-objects)))
          (if (eq? types #t) 'objects
              (for (type types) (cond ((memq type all-objects) (found 'objects))
                                      ((not (org-element-greater-element? type))
                                       (set! gran 'elements)))))
          (found gran))))



    (def results [])

    (let ((granulatity (granularity))
          (no-recursion (if (symbol? no-recursions) (list no-recursions) no-recursions)))
      (let/cc first-match

        (let walk-tree ((d data))
          (let ((type (org-element-type d)))
            (cond
             ((or (null? d) (not d)) #f)
             ;; A list (like o-e-contents returns)
             ((and (not type) (list? d)) (for (d d) (walk-tree d)))
             ;; If it's a parse-tree (aka (org-data [] contents ...)), walk the contents
             ((eq? type 'org-data) (walk-tree (org-element-contents d)))
             ((not type) (error "No element type for " d))
             (#t
              (let (el d)
                ;; If we map this type, call the fn
                (when (map-type? type)
                  (let (r (fn el))
                    (and r (if first? (.begin (set! results r) (first-match))
                               (push! r results)))))

                ;; If this type has a secondary string, walk it.
                (cond ((and (eq? granularity 'objects) (org-element-secondary-value el))
                       => (cut walk-tree <>)))

                ;; If there's a keyword that has objects, and ~with-affiliated~ says
                ;; to walk them, walk it.

                (when (and with-affiliated? (eq? granularity 'objects)
                           (or (org-element-element? el)    
                               (org-element-greater-element? el))) 
                  (for ([name . key] parsed-properties-alist)      
                    (let (val (org-element-property key el))       
                      (and val (not (void? val))                                 
                           (cond                                   
                            ;; Ok, if this is a dual-keyword, that means that its 
                            ;; value is (cons x y), were the first is last. 
                            ((memq key dual-keywords) 
                             ;; If it's a multiple, we parse it as a list where 
                             ;; last comes first. ;
                             (if (memq key multiple-keywords)       
                               (for ([y . x] (reverse val))         
                                 (walk-tree x) (walk-tree y))       
                               (match val ([y . x] (walk-tree x) (walk-tree y))))) 
                            ;; If it's a multiple, we parse it as a list where 
                            ;; last comes first 
                            ((memq key multiple-keywords) (walk-tree (reverse val))) 
                            ;; Otherwise, just walk it ;
                            (#t (walk-tree val)))))))

                ;; Now, should we recurse?
                (unless (or 
                          ;; If there's no recursion specficically 
                          (memq type no-recursion)  
                          ;; or no contents 
                          (not (org-element-contents el)) 
                          ;; Or we're not going that far 
                          (and (eq? granularity 'greater-elements) 
                               (not (org-element-greater-element? el))) 
                          ;; Like, we want elements, but this is not one 
                          (and (eq? granularity 'elements) 
                               (not (org-element-element? el))))
                  (walk-tree (org-element-contents el))))))))))

      ;; we've walked it, return the results
      (if (list? results) (reverse results) results))


#+end_src

  For example, it can be used to collect data from an AST.  Hence the
  following snippet returns all paragraphs beginning a section in the
  current document.  Note that equality between elements is tested
  with ~eq~.

  #+name: collect
  #+BEGIN_SRC emacs-lisp :noweb-ref collect
  (org-element-map (parse-buffer) 'paragraph
    (lambda (paragraph)
      (let ((parent (org-element-property :parent paragraph)))
        (and (eq (org-element-type parent) 'section)
             (let ((first-child (car (org-element-contents parent))))
               (eq first-child paragraph))
             ;; Return value.
             paragraph))))
  #+END_SRC

  It can also be used as a predicate.  Thus, the following snippet
  returns a non-nil value when the document contains a checked item.

  #+name: checkedp
  #+BEGIN_SRC emacs-lisp :noweb-ref checkedp
  (org-element-map (org-element-parse-buffer) 'item
    (lambda (item) (eq (org-element-property :checkbox item) 'on))
    nil t)
  #+END_SRC
  
  See ~org-element-map~'s docstring for more examples.

* Setters
  :PROPERTIES:
  :CUSTOM_ID: setters
  :header-args: :noweb-ref setters-code
  :END:

  ~org-element-property-set!~ (called ~org-element-put-property~ in Emacs)
   modifies any property of a given element or object.

  #+begin_src gerbil
    (def (org-element-property-set! prop el value)
      (def (%set!)
        (def props (let lp ((ps (cadr el)))
                   (cond ((null? ps) [])
                         ((eq? prop (car ps))
                          (lp (cddr ps)))
                         (#t 
                          (cons* (first ps) (second ps) (lp (cddr ps)))))))
        (set-car! (cdr el) (cons* prop value props)))

      (if (string? el) (plain-text-property-set! prop el value)
          (%set!)))

  #+end_src

  Note that, even though structures obtained with local parsers are
  mutable, it is good practice to consider them immutable.  In
  particular, destructively changing properties relative to buffer
  positions is likely to break the caching mechanism running in the
  background.  If, for example, you need to slightly alter an element
  obtained using these functions, first copy it, using
  ~org-element-copy~, before modifying it by side effect.  There is no
  such restriction for elements grabbed from a complete AST.

  The library also provides tools to manipulate the parse tree.  Thus,
  ~org-element-extract-element~ removes an element or object from an
  AST, ~org-element-set-element~ replaces one with another, whereas
  ~org-element-insert-before~ and ~org-element-adopt-element~ insert
  elements within the tree, respectively before a precise location or
  after all children.

* INPROGRESS Types and Attributes
  :PROPERTIES:
  :CUSTOM_ID: attributes
  :header-args: :noweb-ref object-parser
  :END:

  Each greater element, element and object has a variable set of
  properties attached to it.  Among them, four are shared by all
  types: ~begin:~ and ~end:~, which refer to the beginning and ending
  buffer positions of the considered element or object, ~post-blank:~,
  which holds the number of blank lines, or white spaces, at its
  end[fn:2] and ~parent:~, which refers to the element or object
  containing it.

  For an element, when the last item of contents contains a ~post-blank:~, we
  must steal it.

  #+begin_src gerbil :noweb-ref take-post-blank
    (def (org-element-take-post-blank
          parent (child (let (c (org-element-contents parent))
                          (and c (last c)))))
      ;; => parent
      (begin0 parent
        (when child
          (set! (org-element-property post-blank: parent) 
            (org-element-property post-blank: child))
          (set! (org-element-property post-blank: child) 0)
          (set! (org-element-property end: parent)
            (org-element-property end: child))
          (when (org-element-property contents-end: child)
            (set! (org-element-property contents-end: parent)
              (org-element-property contents-end: child))
            (set! (org-element-property end: child)
              (org-element-property contents-end: child))))))
  #+end_src

#+begin_src gerbil :noweb-ref test-post-blank
  (def test-take-post-blank
    (test-suite "take-post-blank"
    (test-case "Testing adoption by taking post blank"
     (def testb  "first-section with post-blanks\n\n\n* Starting header")
     (def el (run (.let* ((beg (point)) (parent (return ['parent [begin: beg]])))
                      (parse-elements 0 1024 'end-at-heading #f #f parent))
                  testb))
     (def pg (car (org-element-contents el)))

     (check-eqv? #f (org-element-property end: el))
     (check-eqv? 33 (org-element-property end: pg))
     (check-eqv? 31 (org-element-property contents-end: pg))
     (check-eqv? 2 (org-element-property post-blank: pg))

     (org-element-take-post-blank el)

     (check-eqv? 33 (org-element-property end: el))
     (check-eqv? 31 (org-element-property end: pg))
     (check-eqv? 31 (org-element-property contents-end: pg))
     (check-eqv? (org-element-property contents-end: el)
                 (org-element-property contents-end: pg))
     (check-eqv? 0 (org-element-property post-blank: pg))
     (check-eqv? 2 (org-element-property post-blank: el)))))



#+end_src

  Greater elements containing objects on the one hand, and elements or
  objects containing objects on the other hand also have
  ~:contents-begin~ and ~:contents-end~ properties to delimit
  contents.
  
** INPROGRESS Affiliated Keywords
   :PROPERTIES:
   :header-args: :noweb-ref affiliated-keywords
   :END:
  
  In addition to these properties, each element can optionally get
  some more from affiliated keywords, namely: ~caption:~, ~header:~,
  ~name:~, ~plot:~, ~results:~ or ~attr_NAME:~ where =NAME= stands for
  the name of an export back-end.


  Also, ~post-affiliated:~ property is attached to all elements.  It
  refers to the buffer position after any affiliated keyword, when
  applicable, or to the beginning of the element otherwise.

#+begin_src gerbil
  (defconst affiliated-keywords
    '("CAPTION" "DATA" "HEADER" "HEADERS" "LABEL" "NAME" "PLOT" "RESNAME" "RESULT"
      "RESULTS" "SOURCE" "SRCNAME" "TBLNAME"))

  ;; The key is the old name and the value the new one.")
  (defconst keyword-translation-alist
    '(("DATA" . "NAME")  ("LABEL" . "NAME") ("RESNAME" . "NAME")
      ("SOURCE" . "NAME") ("SRCNAME" . "NAME") ("TBLNAME" . "NAME")
      ("RESULT" . "RESULTS") ("HEADERS" . "HEADER")))

  ;;  Affiliated keywords can occur more than once in an element. By default, all
  ;;  keywords setting attributes (e.g., "ATTR_LATEX") allow multiple occurrences.
  (defconst multiple-keywords '("CAPTION" "HEADER"))

  ;; Affiliated keywords whose value can be parsed.
  (defconst parsed-keywords '("CAPTION"))

  ;; Affiliated keywords can have a secondary[value].
  (defconst dual-keywords '("CAPTION" "RESULTS"))
#+end_src


#+begin_src gerbil

  (def (collect-affiliated-keywords (limit +inf.0))
     ;; => /list/
    (def KEY (apply .any (map ci=? affiliated-keywords)))
    (def (afks (alist []))
      (.or 
       (.let*
        ( ;; make sure we're before the limit
         (_ (sat (cut < <> limit) (point)))
         ;; Find the afk
         (afk (AFFILIATED-KEYWORD KEY)))
        (let* ( ;; Take the keyword out of it
               (afkey (org-element-property key: afk))
               ;; Make sure we match the modern key
               (key (or (assget afkey keyword-translation-alist) afkey))
               ;; Now the value
               (val (org-element-property value: afk))
               ;; If we're parsed, parse!
               (restrict (org-element-object-restrictions 'keyword))
               (parse? (member key parsed-keywords))
               (val (if parse?
                        (run (parse-objects 0 +inf.0 #f restrict) val)
                      val))
               ;; If ~key~ is a dual keyword, find its secondary value.
               (dual? (member key dual-keywords))
               (dual-val (and dual? (org-element-property option: afk)))
               ;;Maybe parse it.
               (dual-val
                (and dual-val
                     (if (not parse?) dual-val
                         (run (parse-objects 0 +inf.0 #f restrict) dual-val))))
               ;; And add it to the value
               (val (if (and dual? (or val dual-val)) (cons val dual-val) val))
               ;; Now, if this is one that can have many values, and one exists,
               ;; we'll cons it up.
               (val (if (or (member key multiple-keywords)
                            (string= key "ATTR_" 0 5))
                      (let (ac (assoc key alist))
                        (if (not ac) val (cons val (let (r (cdr ac))
                                                     (if (list? r) r (list r))))))
                      val))
               ;; name a new alist with this new key/val
               (new-alist (cons (cons key val) (alist-delete key alist))))
          ;; now call us again
          (afks new-alist)))

       (if (null? alist)
         (return #f)
         (return (append-map (lambda (ac) (list (string->keyword (string-downcase (car ac)))
                                     (cdr ac))) alist)))))

    (.let* ((b (point)) (lst (afks))) (if lst (cons b lst) [])))
#+end_src
 

** Position and Properties
  The following example illustrates the relationship between position
  properties.

  #+name: position-properties
  #+BEGIN_SRC org -n -r :noweb-ref position-properties
  ,#+NAME: dont-do-this-at-home (ref:begin)
  ,#+BEGIN_SRC emacs-lisp       (ref:post)
  (/ 1 0)
  ,#+END_SRC

  Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do (ref:end)
  eiusmod tempor incididunt ut labore et dolore magna aliqua.
  #+END_SRC

  The first element's type is ~src-block~.  Its ~begin:~ property
  (respectively ~end:~ property) is the buffer position at the
  beginning of line (begin) (respectively line (end)).
  ~post-affiliated:~ is the buffer position at the beginning of line
  (post).  Since source blocks cannot contain other elements or
  objects, both ~:contents-begin~ and ~:contents-end~ are
  nil. ~:post-blank~ is 1.

  Other properties, specific to each element or object type, are
  listed below.

** Babel Call

   Element.

   - ~:call~ :: Name of code block being called (string).
   - ~:inside-header~ :: Header arguments applied to the named code
        block (string or nil).
   - ~:arguments~ :: Arguments passed to the code block (string or
        nil).
   - ~:end-header~ :: Header arguments applied to the calling instance
        (string or nil).
   - ~:value~ :: Raw call, as Org syntax (string).

** DONE Bold     `                                          :RecursiveObject:
   CLOSED: [2019-11-16 Sat 23:29]

   Recursive object.

   No specific property.

   '*This +is+ bold!*'

   Bold is just the first mentioned ~emphasis~ element.


   #+begin_src gerbil :noweb-ref emphasis-objects
  (def (bold-parser)
    (.begin (peek #\*) (emphasis-parser)))
   #+end_src

*** Emphasis Elements (*,=,+,_,~,-)

   CONTENTS can contain any object encountered in a paragraph when
   markup is "bold", "italic", "strike-through" or "underline".
#+NAME: emphasis-parser
   #+begin_src gerbil :noweb-ref emphasis-parser
     (def (emphasis-parser)
       TEXT-MARKUP)
   #+end_src


** Center Block

   Greater element.

   No specific property.

** Clock

   Element.

   - ~:duration~ :: Clock duration for a closed clock, or nil (string
                    or nil).
   - ~:status~ :: Status of current clock (symbol: ~closed~ or
                  ~running~).
   - ~:value~ :: Timestamp associated to clock keyword (timestamp
                 object).

** DONE Code                                                         :Object:
   CLOSED: [2019-11-16 Sat 23:29]

   Object.

   - ~value:~ :: Contents (string).


#+begin_src gerbil :noweb-ref emphasis-objects
  (def (code-parser)
   (.begin (peek #\~) (emphasis-parser)))
#+end_src

** Comment

   Element.

   - ~:value~ :: Comments, with pound signs (string).

** Comment Block

   Element.

   - ~:value~ :: Comments, without block's boundaries (string).

** Diary Sexp

   Element.

   - ~:value~ :: Full Sexp (string).

** Drawer

   Greater element.

   - ~:drawer-name~ :: Drawer's name (string).

** Dynamic Block

   Greater element.

   - ~:arguments~ :: Block's parameters (string).
   - ~:block-name~ :: Block's name (string).
   - ~:drawer-name~ :: Drawer's name (string).

** Entity

   Object.

   - ~:ascii~ :: Entity's ASCII representation (string).
   - ~:html~ :: Entity's HTML representation (string).
   - ~:latex~ :: Entity's LaTeX representation (string).
   - ~:latex-math-p~ :: Non-nil if entity's LaTeX representation
        should be in math mode (boolean).
   - ~:latin1~ :: Entity's Latin-1 encoding representation (string).
   - ~:name~ :: Entity's name, without backslash nor brackets
                (string).
   - ~:use-brackets-p~ :: Non-nil if entity is written with optional
        brackets in original buffer (boolean).
   - ~:utf-8~ :: Entity's UTF-8 encoding representation (string).

** Example Block

   Element.

   - ~:label-fmt~ :: Format string used to write labels in current
                     block, if different from
                     ~org-coderef-label-format~ (string or nil).
   - ~:language~ :: Language of the code in the block, if specified
                    (string or nil).
   - ~:number-lines~ :: Non-nil if code lines should be numbered.
        A ~new~ value starts numbering from 1 wheareas ~continued~
        resume numbering from previous numbered block (symbol: ~new~,
        ~continued~ or nil).
   - ~:options~ :: Block's options located on the block's opening line
                   (string).
   - ~:parameters~ :: Optional header arguments (string or nil).
   - ~:preserve-indent~ :: Non-nil when indentation within the block
        mustn't be modified upon export (boolean).
   - ~:retain-labels~ :: Non-nil if labels should be kept visible upon
        export (boolean).
   - ~:switches~ :: Optional switches for code block export (string or
                    nil).
   - ~:use-labels~ :: Non-nil if links to labels contained in the
                      block should display the label instead of the
                      line number (boolean).
   - ~:value~ :: Contents (string).

** Export Block

   Element.

   - ~:type~ :: Related back-end's name (string).
   - ~:value~ :: Contents (string).

** Export Snippet

   Object.

   - ~:back-end~ :: Relative back-end's name (string).
   - ~:value~ :: Export code (string).

** Fixed Width

   Element.

   - ~:value~ :: Contents, without colons prefix (string).

** Footnote Definition

   Greater element.

   - ~:label~ :: Label used for references (string).
   - ~:pre-blank~ :: Number of newline characters between the
        beginning of the footnoote and the beginning of the contents
        (0, 1 or 2).

** Footnote Reference

   Recursive object.

   - ~:label~ :: Footnote's label, if any (string or nil).
   - ~:type~ :: Determine whether reference has its definition inline,
                or not (symbol: ~inline~, ~standard~).

** INPROGRESS Headline                                       :GreaterElement:
   :PROPERTIES:
   :header-args: :noweb-ref headline-element 
   :END:

   Greater element.

   In addition to the following list, any property specified in
   a property drawer attached to the headline will be accessible as an
   attribute (with an uppercase name, e.g. ~CUSTOM_ID:~).



   - ~archived?:~ :: True if the headline has an archive tag
                     (boolean).
   - ~closed:~ :: Headline's CLOSED reference, if any (timestamp
                  object or #f)
   - ~commented?:~ :: #t if the headline has a comment keyword
                      (boolean).
   - ~deadline:~ :: Headline's DEADLINE reference, if any (timestamp
                    object or #f).
   - ~footnote-section?:~ ::  #t if the headline is a footnote section
                               (boolean).
   - ~level:~ :: Reduced level of the headline (integer).
   - ~pre-blank:~ :: Number of blank lines between the headline and
                     the first non-blank line of its contents
                     (integer).
   - ~priority:~ :: Headline's priority, as a character.
   - ~quoted?:~ :: #t if the headline contains a quote keyword
                   (boolean).
   - ~raw-value:~ :: Raw headline's text, without the stars and the
                     tags (string).
   - ~scheduled:~ :: Headline's SCHEDULED reference, if any (timestamp
                     object or nil).
   - ~tags:~ :: Headline's tags, if any, without the archive
                tag. (list of strings).
   - ~title:~ :: Parsed headline's text, without the stars and the
                 tags (secondary string).
   - ~todo-keyword:~ :: Headline's TODO keyword without quote and
        comment strings, if any (string or #f).
   - ~todo-type:~ :: Type of headline's TODO keyword, if any (symbol:
                     ~done~, ~todo~).

[[file:~/.emacs.d/elpa/org-plus-contrib-20190408/org-element.el::(defun%20org-element-headline-parser%20(limit%20&optional%20raw-secondary-p)][emacs lisp]]

#+begin_src gerbil 
  (def (headline-parser (raw-secondary? #f) (granularity 'headline))
    (def NODE-PROPERTIES
      (.let* (pd PROPERTYDRAWER)
         (append-map!
          (lambda (np) [(string->keyword (string-upcase (org-element-property key: np)))
                   (org-element-property value: np)])
          (org-element-contents pd))))
    (.let*
     ((beg (point)) (h (HEADLINE))
      (stars (return (org-element-property stars: h)))
      (todo (return (org-element-property todo-keyword: h)))
      (raw-value (return (org-element-property title: h)))
      (title-end  (point))
      (level (return (length stars)))
      (time-props (.or (PLANNING (timestamp-parser)) []))
      (standard-props (.or NODE-PROPERTIES []))
      (contents-begin (.or (save-excursion
                            (goto-char title-end)
                             (skip-chars-forward " \n\r\t")
                             (.let* (pos (beginning-of-line))
                               (return (if (= pos beg) #f pos))))
                           #f))
      (pre-blank (if (not contents-begin) (return 0)
                     (count-lines title-end contents-begin)))
      (ss (and contents-begin
               (.or
                 (parse-elements
                  contents-begin +inf.0 'section #f granularity)
                 #f)))
      (_ (.let* (a #f) (displayln "Got a section " ss) #f))
      (subtrees (and ss 
                     (parse-elements
                      (if (pair? ss) (org-element-property end: (car ss)) contents-begin)
                      +inf.0 ['end-of-subtree level] #f granularity)))
      (end (point))


      (contents-end (.or (save-excursion
                          (goto-char end)
                          (skip-chars-backward " \n\r\t")
                          (beginning-of-line 2))
                         #f))
      (post-blank  (if (not contents-end) (return 0)
                       (count-lines contents-end end))))

        (let (headline
              (cons*
               'headline
               (append!
                (list ;foo: title-end
                      raw-value: raw-value
                      begin: beg end: end
                      pre-blank: pre-blank
                      contents-begin: contents-begin
                      contents-end: (and contents-begin contents-end)
                      post-blank: post-blank
                      level: level
                      priority: (org-element-property priority: h)
                      tags: (org-element-property tags: h)
                      todo-keyword: todo
                      todo-type: (if todo
                                   (if (member todo (org-env-ref 'org-done-keywords))
                                     'done 'todo)
                                   #f)
                      footnote-section?: (org-element-property footnote-section?: h)
                      archived?: (org-element-property archived?: h)
                      commented?: (org-element-property commented?: h)
                      post-affiliated: beg)
                (append time-props standard-props))
               (if (and ss subtrees) (append ss subtrees) [])))
          (begin0 headline
            (set! (org-element-property title: headline)
              (if raw-secondary? raw-value
                  (run (parse-objects
                        0 +inf.0 #f (org-element-object-restrictions 'headline)
                        headline) raw-value)))))))







#+end_src

*** INPROGRESS Usage and Testing 
    :PROPERTIES:
    :header-args: :noweb-ref headline-test
    :END:


#+begin_src gerbil 
  (def headline-test
    (test-suite
     "Test suite for parsing headlines"

     (test-case
      "No linebreak"
      (def el (run (headline-parser) "* Headline with no linebreak"))
      (check-eqv? (org-element-property begin: el) 0)
      (check-eqv? (org-element-property end: el) 28)
      (check (and (not (org-element-property contents-begin: el))
                  (not (org-element-property contents-end: el)))
             => #t)
      (check-equal? (org-element-property title: el) '("Headline with no linebreak")))

     (test-case
      "Many headlines, empty, no break at the end"
      (def doc  "* 234
  ,** 90
  ,*** 67
  ,**** 4567
  ,***** 56789")
      (def el (run (headline-parser) doc))

      (check-eqv? (org-element-property end: el) 40)
      (check-eqv? #\9 (run (.begin (goto-char 39) (item)) doc))
      ;; See if the contents start the next headline
      (def el2 (run (.begin (goto-char (org-element-property contents-begin: el))
                            (headline-parser)) doc))

      (check-equal? (org-element-property raw-value: el2) "90")

      (check-eqv? (org-element-property end: el)
                  (org-element-property end: el2)))))
#+end_src
** Horizontal Rule

   Element.

   No specific property.

** Inline Babel Call

   Object.

   - ~:call~ :: Name of code block being called (string).
   - ~:inside-header~ :: Header arguments applied to the named code
        block (string or nil).
   - ~:arguments~ :: Arguments passed to the code block (string or
        nil).
   - ~:end-header~ :: Header arguments applied to the calling instance
        (string or nil).
   - ~:value~ :: Raw call, as Org syntax (string).
** Inline Src Block

   Object.

   - ~:language~ :: Language of the code in the block (string).
   - ~:parameters~ :: Optional header arguments (string or nil).
   - ~:value~ :: Source code (string).

** Inlinetask

   Greater element.

   In addition to the following list, any property specified in
   a property drawer attached to the headline will be accessible as an
   attribute (with an uppercase name, e.g. ~:CUSTOM_ID~).

   - ~:closed~ :: Inlinetask's CLOSED reference, if any (timestamp
                  object or nil)
   - ~:deadline~ :: Inlinetask's DEADLINE reference, if any (timestamp
                    object or nil).
   - ~:level~ :: Reduced level of the inlinetask (integer).
   - ~:priority~ :: Headline's priority, as a character (integer).
   - ~:raw-value~ :: Raw inlinetask's text, without the stars and the
                     tags (string).
   - ~:scheduled~ :: Inlinetask's SCHEDULED reference, if any
                     (timestamp object or nil).
   - ~:tags~ :: Inlinetask's tags, if any (list of strings).
   - ~:title~ :: Parsed inlinetask's text, without the stars and the
                 tags (secondary string).
   - ~:todo-keyword~ :: Inlinetask's TODO keyword, if any (string or
        nil).
   - ~:todo-type~ :: Type of inlinetask's TODO keyword, if any
                     (symbol: ~done~, ~todo~).

** Italic                                                   :RecursiveObject:

   Recursive object.

   No specific property.

#+begin_src gerbil :noweb-ref emphasis-objects
  (def (italic-parser)
   (.begin (peek #\/) (emphasis-parser)))
#+end_src

** Item

   Greater element.

   - ~:bullet~ :: Item's bullet (string).
   - ~:checkbox~ :: Item's check-box, if any (symbol: ~on~, ~off~,
                    ~trans~, nil).
   - ~:counter~ :: Item's counter, if any.  Literal counters become
                   ordinals (integer).
   - ~:pre-blank~ :: Number of newline characters between the
        beginning of the item and the beginning of the contents (0,
        1 or 2).
   - ~:raw-tag~ :: Uninterpreted item's tag, if any (string or nil).
   - ~:tag~ :: Parsed item's tag, if any (secondary string or nil).
   - ~:structure~ :: Full list's structure, as returned by
                     ~org-list-struct~ (alist).

** Keyword

   Element.

   - ~:key~ :: Keyword's name (string).
   - ~:value~ :: Keyword's value (string).

** LaTeX Environment

   Element.

   - ~:begin~ :: Buffer position at first affiliated keyword or at the
                 beginning of the first line of environment (integer).
   - ~:end~ :: Buffer position at the first non-blank line after last
               line of the environment, or buffer's end (integer).
   - ~:post-blank~ :: Number of blank lines between last environment's
                      line and next non-blank line or buffer's end
                      (integer).
   - ~:value~ :: LaTeX code (string).

** LaTeX Fragment

   Object.

   - ~:value~ :: LaTeX code (string).

** Line Break

   Object.

   No specific property.

** Link

   Recursive object.

   - ~:application~ :: Name of application requested to open the link
                       in Emacs (string or nil). It only applies to
                       "file" type links.
   - ~:format~ :: Format for link syntax (symbol: ~plain~, ~angle~,
        ~bracket~).
   - ~:path~ :: Identifier for link's destination.  It is usually the
                link part with type, if specified, removed (string).
   - ~:raw-link~ :: Uninterpreted link part (string).
   - ~:search-option~ :: Additional information for file location
        (string or nil). It only applies to "file" type links.
   - ~:type~ :: Link's type.  Possible types (string) are:

     - ~coderef~ :: Line in some source code,
     - ~custom-id~ :: Specific headline's custom-id,
     - ~file~ :: External file,
     - ~fuzzy~ :: Target, referring to a target object, a named
                  element or a headline in the current parse tree,
     - ~id~ :: Specific headline's id,
     - ~radio~ :: Radio-target.

     It can also be any type defined in ~org-link-types~.

** Macro

   Object.

   - ~:args~ :: Arguments passed to the macro (list of strings).
   - ~:key~ :: Macro's name (string).
   - ~:value~ :: Replacement text (string).

** Node Property

   Element.

   - ~:key~ :: Property's name (string).
   - ~:value~ :: Property's value (string).

** INPROGRESS Paragraph                                             :Element:

   Element containing objects.

   No specific property.
   Empty lines and other elements end paragraphs.

#+NAME: paragraph-parser
#+begin_src gerbil 
  (def (paragraph-parser (afk []) values: (return-next-element-as-well #f)
                         granularity: (granularity #f))
    (def EMPTY-LINE (.begin (skip WS) (.or #\newline EOF)))
    (def END-PARAGRAPH
      (.or (parse-current-element granularity 'no-paragraph #f) EMPTY-LINE))

    (def (para)
      (.let* ((pos (.begin SKIP-LINE (point)))
              (end? (.or END-PARAGRAPH (.not (item)) #f)))
        (if end?
          (return (values pos end?))
          (para))))

    (.let* ((beg (.begin (.not EOF) (point)))
            ((values lend end-el) (para))
            (end (if (org-element? end-el)
                   (return (org-element-property begin: end-el))
                   (.begin (skip-chars-forward " \n\r\t")
                           (point))))
            (post-blank (count-lines lend end))
            (_ (goto-char end)))
      (let (paragraph ['paragraph (cons* begin: (if (null? afk) beg (car afk))
                                         end: end
                                         contents-begin: beg
                                         contents-end:
                                         (if (eof-object? end-el)
                                           end lend)
                                         post-blank: post-blank
                                         post-affiliated: beg
                                         afk)])
        (if return-next-element-as-well
          (values paragraph (if (org-element? end-el) end-el #f))
          paragraph))))
#+end_src


*** Test it out

#+NAME: paragraph-test
#+begin_src gerbil 
    (def paragraph-test
      (test-suite
       "Test suite for parsing paragraphs from test/paragraph.org"

      (test-case "Paragraph parsing with headline to end"
       (def p-string "This is the first paragraph.\nThis is a part of the first paragraph.\n\nThe blank line should have ended it, so this is the second.\n\n\n\nThose blank lines ended that one, so now we're on the third.\n* This headline ends the Third, no linebreak")

       (def paragraphs (run (many (paragraph-parser)) p-string))

       (def values-of-elements (run (many (paragraph-parser [] values: #t)) p-string))
       (def our-elements
         (append-map (lambda (vs) (let ((values p next) vs) (cons p (if next [next] []))))
                     values-of-elements))
       (def our-paragraphs (filter (lambda (el) (eq? (org-element-type el) 'paragraph)) our-elements))

       (def actual-elements (run (many (parse-current-element)) p-string))

       (def actual-paragraphs (filter (lambda (el) (eq? (org-element-type el) 'paragraph)) actual-elements))
       (check-equal? paragraphs our-paragraphs)
       ;; We parse the headline as a headline and a paragraph. parse-current-element
       ;; is smarter.
       (check-equal? actual-paragraphs (take our-paragraphs 3))
       (check-equal? (take our-elements 4) actual-elements))

      (test-case
       "No linebreak always messed me up"
       (def pstr "This is a paragraph
  This is the second line of the paragraph
  This is the third, ends it with EOF")


       )

    
    
  ))


#+end_src

** Plain List

   Greater element.

   - ~:structure~ :: Full list's structure, as returned by
                     ~org-list-struct~ (alist).
   - ~:type~ :: List's type (symbol: ~descriptive~, ~ordered~,
                ~unordered~).

** Planning

   Element.

   - ~:closed~ :: Timestamp associated to closed keyword, if any
                  (timestamp object or nil).
   - ~:deadline~ :: Timestamp associated to deadline keyword, if any
                    (timestamp object or nil).
   - ~:scheduled~ :: Timestamp associated to scheduled keyword, if any
                     (timestamp object or nil).

** Property Drawer

   Greater element.

   No specific property.

** Quote Block

   Greater element.

** Radio Target

   Recursive object.

   - ~:raw-value~ :: Uninterpreted contents (string).

** INPROGRESS Section
   :PROPERTIES:
   :CUSTOM_ID: Section
   :END:

   Greater element.

   No specific property.

#+NAME: section-parser
#+begin_src gerbil
  (def (section-parser (granularity #f))
    (.let* ((beg (point))
            (section (return ['section (list begin: beg contents-begin: beg
                                             post-affiliated: beg)]))
            ;; This is called by headline, so there is no pre-blanks, and contents
            ;; start here as well. Anything before the next heading is an element
            ;; in this section
            (contents (parse-elements
                       beg +inf.0 'end-at-heading #f granularity section)))
      ;; With no contents, there is no section. Fail.
      (if (not (org-element-contents section)) (fail)
      ;; If the last of the contents is an element, steal the post-blank and fix the end.
          (begin0 section (org-element-take-post-blank section)))))


#+end_src


*** Emacs 

#+begin_src emacs-lisp
(defun org-element-section-parser (_)
  "Parse a section.

Return a list whose CAR is `section' and CDR is a plist
containing `:begin', `:end', `:contents-begin', `contents-end',
`:post-blank' and `:post-affiliated' keywords."
  (save-excursion
    ;; Beginning of section is the beginning of the first non-blank
    ;; line after previous headline.
    (let ((begin (point))
	  (end (progn (org-with-limited-levels (outline-next-heading))
		      (point)))
	  (pos-before-blank (progn (skip-chars-backward " \r\t\n")
				   (line-beginning-position 2))))
      (list 'section
	    (list :begin begin
		  :end end
		  :contents-begin begin
		  :contents-end pos-before-blank
		  :post-blank (count-lines pos-before-blank end)
		  :post-affiliated begin)))))
#+end_src
** Special Block

   Greater element.

   - ~:type~ :: Block's name (string).
   - ~:raw-value~ :: Raw contents in block (string).

** Src Block

   Element.

   - ~:label-fmt~ :: Format string used to write labels in current
                     block, if different from
                     ~org-coderef-label-format~ (string or nil).
   - ~:language~ :: Language of the code in the block, if specified
                    (string or nil).
   - ~:number-lines~ :: Non-nil if code lines should be numbered.
        A ~new~ value starts numbering from 1 wheareas ~continued~
        resume numbering from previous numbered block (symbol: ~new~,
        ~continued~ or nil).
   - ~:parameters~ :: Optional header arguments (string or nil).
   - ~:preserve-indent~ :: Non-nil when indentation within the block
        mustn't be modified upon export (boolean).
   - ~:retain-labels~ :: Non-nil if labels should be kept visible upon
        export (boolean).
   - ~:switches~ :: Optional switches for code block export (string or
                    nil).
   - ~:use-labels~ :: Non-nil if links to labels contained in the
                      block should display the label instead of the
                      line number (boolean).
   - ~:value~ :: Source code (string).

** Statistics Cookie

   Object.

   - ~:value~ :: Full cookie (string).

** DONE Strike Through                                      :RecursiveObject:
   CLOSED: [2019-11-16 Sat 23:29]

   Recursive object.

   No specific property.


   #+begin_src gerbil :noweb-ref emphasis-objects
  (def (strike-through-parser)
    (.begin (peek #\+) (emphasis-parser)))
   #+end_src
** Subscript

   Recursive object.

   - ~:use-brackets-p~ :: Non-nil if contents are enclosed in curly
        brackets (t, nil).

** Superscript

   Recursive object.

   - ~:use-brackets-p~ :: Non-nil if contents are enclosed in curly
        brackets (t, nil).

** INPROGRESS Table                                          :GreaterElement:
   :PROPERTIES:
   :END:

   Greater element.

   - ~tblfm:~ :: Formulas associated to the table, if any (string or
                 nil).
   - ~type:~ :: Table's origin (symbol: ~table.el~, ~org~).
   - ~value:~ :: Raw ~table.el~ table or nil (string or nil).

Basically, this table becomes the following when parsed in full.

#+NAME: this is a table
  | N | N^2 | N^3 | N^4 | sqrt(n) | sqrt[4](N) |
  |---+-----+-----+-----+---------+------------|
  | / |   < |     |   > |       < |          > |
  | 1 |   1 |   1 |   1 |       1 |          1 |
  | 2 |   4 |   8 |  16 |  1.4142 |     1.1892 |
  | 3 |   9 |  27 |  81 |  1.7321 |     1.3161 |
  |---+-----+-----+-----+---------+------------|
#+TBLFM: $2=$1^2::$3=$1^3::$4=$1^4::$5=sqrt($1)::$6=sqrt(sqrt(($1)))


#+begin_src emacs-lisp :results code
  ;; Emacs Lisp
  (set-buffer "element.org")
  (org-element-map (org-element-parse-buffer) '(table) 
    (lambda (tbl)
      (org-element-put-property tbl :parent '())
      (list (car tbl) (cadr tbl)))
    nil t)
#+end_src

#+begin_src emacs-lisp
(table
 (:begin 35374 :end 35798 :type org :tblfm
         ("$2=$1^2::$3=$1^3::$4=$1^4::$5=sqrt($1)::$6=sqrt(sqrt(($1)))")
         :contents-begin 35398 :contents-end 35727 :value nil :post-blank 2 :post-affiliated 35398 
         :name "this is a table" :parent nil))
#+end_src

#+begin_src gerbil :noweb-ref table-parser
  (def (table-parser (affiliated []) (granularity 'greater-element))
    ;; ~affiliated~ is a list of which ~car~ is the buffer position at the
    ;; beginning of the first affiliated keyword and ~cdr~ is a plist of
    ;; affiliated keywords along with their value.

    ;; If ~table-row~ is a parser, use that and return contents. This saves time
    ;; and effort for big tables when we actually want the lines.

    ;; A | followed by anything that is not WS marks a table line

    (def TABLE-ROW
       (if (eq? granularity 'greater-element)
         (.begin (skip WS) #\| (skip WS)
                 (sat (? (not char-whitespace?))) SKIP-LINE)
         (table-row-parser granularity)))

    (.let* ((b (if (not (null? affiliated)) (return (car affiliated)) (point)))
            (table-begin (point))
            (contents (many1 TABLE-ROW))
            (table-end (point))
            (tblfm (.or (many1 TBLFM) #f))
            (pos-before-blank (point))
            (blanks (many (.begin (many WS) #\newline)))
            (end (point))
            (afks (return (if (pair? affiliated) (cdr affiliated) []))))
      (let (el ['table (cons* begin: b end: end type: 'org tblfm: tblfm
                             contents-begin: table-begin contents-end: table-end
                             ;;; emacs tables get a value
                             value: #f
                             post-blank: (length blanks)
                             post-affiliated: table-begin
                             afks)])

         (begin0 (return el)
           (unless (eq? granularity 'greater-element)
             (set! (org-element-contents el) contents))))))
#+end_src



   |   |

   | asd | asd |
   |-----+-----|
   |     |     |


   


   
*** Interpret data  

To write a table is very simple. 

#+begin_src gerbil
  (import :std/iter)
  (def (table-intepreter table)
    (let ((rows (org-element-contents table)))
      (with-output-to-string
        ""
        (cut for (row rows)
             (let (type (org-element-property type: row))
               (display #\|)
               (let dcs ((cells (org-element-contents row)))
                 (unless (null? cells)
                   (let (cell (car cells))
                     (display (org-element-contents cell))
                     (case type
                       ((standard) (map display (org-element-property spaces: cell) [])
                        (display #\|))
                       ((rule) (display (if (null? (cdr cells)) #\| #\+)))))
                   (dcs (cdr cells)))))
             (display #\newline)))))



#+end_src

   

  

  


** Table Row                                                        :Element:

   Element containing objects.

   - ~:type~ :: Row's type (symbol: ~standard~, ~rule~).

  #+begin_src gerbil :noweb-ref table-parser
    (def (table-row-parser  (granularity 'element))
      (.let* ((beg (point))
              (cbeg (.begin (skip WS) #\| (point)))
              (type (.or (.begin (sat (? (cut char=? #\- <>)) (peek))
                                 (return 'rule))
                         (return 'standard)))
              (lend (end-of-line))
              (cend (save-excursion
                     (skip-chars-backward " \t")
                     (point)))
              (end (.begin (.or (item) EOF) (point)))
              (row (return ['table-row
                            (list
                             type: type begin: beg end: end
                             contents-begin: cbeg contents-end: cend
                             post-blank: 0 post-affiliated: beg)]))
              (contents (if (not (memq granularity '(object #f))) #f
                            (parse-objects cbeg cend row [(if (eq? type 'rule)
                                                            'table-cell-rule
                                                            'table-cell)]))))
        (return row)))

  #+end_src
*** emacs data 

 #+begin_src emacs-lisp :results code
   ;; Emacs Lisp
   (set-buffer "element.org")
   (org-element-map (org-element-parse-buffer) '(table table-row) 
     (lambda (tbl)
       (org-element-put-property tbl :parent '())
       (list (car tbl) (cadr tbl)))
     nil nil)
 #+end_src

 #+RESULTS:
 #+begin_src emacs-lisp
 ((table
   (:begin 41740 :end 42178 :type org :tblfm
           ("$2=$1^2::$3=$1^3::$4=$1^4::$5=sqrt($1)::$6=sqrt(sqrt(($1)))")
           :contents-begin 41764 :contents-end 42107 :value nil :post-blank 2 :post-affiliated 41764 :name "this is a table" :parent nil))
  (table-row
   (:type standard :begin 41764 :end 41813 :contents-begin 41767 :contents-end 41812 :post-blank 0 :post-affiliated 41764 :parent nil))
  (table-row
   (:type rule :begin 41813 :end 41862 :contents-begin nil :contents-end nil :post-blank 0 :post-affiliated 41813 :parent nil))
  (table-row
   (:type standard :begin 41862 :end 41911 :contents-begin 41865 :contents-end 41910 :post-blank 0 :post-affiliated 41862 :parent nil))
  (table-row
   (:type standard :begin 41911 :end 41960 :contents-begin 41914 :contents-end 41959 :post-blank 0 :post-affiliated 41911 :parent nil))
  (table-row
   (:type standard :begin 41960 :end 42009 :contents-begin 41963 :contents-end 42008 :post-blank 0 :post-affiliated 41960 :parent nil))
  (table-row
   (:type standard :begin 42009 :end 42058 :contents-begin 42012 :contents-end 42057 :post-blank 0 :post-affiliated 42009 :parent nil))
  (table-row
   (:type rule :begin 42058 :end 42107 :contents-begin nil :contents-end nil :post-blank 0 :post-affiliated 42058 :parent nil))
  (table
   (:begin 44129 :end 44139 :type org :tblfm nil :contents-begin 44129 :contents-end 44138 :value nil :post-blank 1 :post-affiliated 44129 :parent nil))
  (table-row
   (:type standard :begin 44129 :end 44138 :contents-begin 44133 :contents-end 44137 :post-blank 0 :post-affiliated 44129 :parent nil))
  (table
   (:begin 44139 :end 44190 :type org :tblfm nil :contents-begin 44139 :contents-end 44190 :value nil :post-blank 0 :post-affiliated 44139 :parent nil))
  (table-row
   (:type standard :begin 44139 :end 44156 :contents-begin 44143 :contents-end 44155 :post-blank 0 :post-affiliated 44139 :parent nil))
  (table-row
   (:type rule :begin 44156 :end 44173 :contents-begin nil :contents-end nil :post-blank 0 :post-affiliated 44156 :parent nil))
  (table-row
   (:type standard :begin 44173 :end 44190 :contents-begin 44177 :contents-end 44189 :post-blank 0 :post-affiliated 44173 :parent nil)))
 #+end_src


  

** Table Cell                                               :RecursiveObject:

   Recursive object.

   No specific property.


#+begin_src gerbil 
  (assgetq 'table-cell object-restrictions)
  ;; =>
  '(bold code entity export-snippet footnote-reference italic latex-fragment link
   macro radio-target strike-through subscript superscript target timestamp
   underline verbatim)
#+end_src


#+begin_src gerbil :noweb-ref table-parser
  (def (table-cell-parser (type 'standard))
    (def STANDARD-CONTENTS (some (sat (? (not (cut member <> '(#\| #\newline)))))))
    (def RULE-CONTENTS (many (sat (cut char=? #\- <>))))

    (.let* ((beg (point))
            (cbeg (.begin (skip WS) (point)))
            (contents (if (eq? type 'standard) STANDARD-CONTENTS RULE-CONTENTS))
            (cend (point))
            (end (.begin (skip WS)
                          (.or (if (eq? type 'standard) #\| (.or #\+ #\|))
                               (peek EOL))
                          (point))))
      (if (= beg end) (fail)
          ['table-cell (list begin: beg end: end
                             contents-begin: cbeg contents-end: cend)])))
#+end_src

 #+begin_src emacs-lisp :results code
   ;; Emacs Lisp
   (set-buffer "element.org")
   (org-element-map (org-element-parse-buffer) '(table-cell) 
     (lambda (tbl)
       (org-element-put-property tbl :parent '())
       tbl)
     nil nil)
 #+end_src

 #+RESULTS:
 #+begin_src emacs-lisp
   ((table-cell
     (:begin 41709 :end 41713 :contents-begin 41710 :contents-end 41711 :post-blank 0 :parent nil)
     #("N" 0 1
       (:parent #1)))
    (table-cell
     (:begin 41713 :end 41719 :contents-begin 41714 :contents-end 41717 :post-blank 0 :parent nil)
     #("N" 0 1
       (:parent #1))
     (superscript
      (:begin 41715 :end 41717 :use-brackets-p nil :contents-begin 41716 :contents-end 41717 :post-blank 0 :parent #1)
      #("2" 0 1
        (:parent #2))))
    ;; [...]
    )
 #+end_src

** Target

   Object.

   - ~:value~ :: Target's ID (string).

** INPROGRESS Timestamp                                              :Object:
   :PROPERTIES:
   :header-args: :noweb-ref timestamp-element
   :END:

   Object.

   - ~day-end:~ :: Day part from timestamp end.  If no ending date is
                   defined, it defaults to start day part (integer).
   - ~day-start:~ :: Day part from timestamp start (integer).
   - ~hour-start:~ :: Hour part from timestamp end. If no ending date
                      is defined, it defaults to start hour part, if
                      any (integer or #f).
   - ~hour-start:~ :: Hour part from timestamp start, if specified
                      (integer or #f).
   - ~minute-start:~ :: Minute part from timestamp end. If no ending
        date is defined, it defaults to start minute part, if any
        (integer or #f).
   - ~minute-start:~ :: Minute part from timestamp start, if specified
        (integer or #f).
   - ~month-end:~ :: Month part from timestamp end.  If no ending date
                     is defined, it defaults to start month part
                     (integer).
   - ~month-start:~ :: Month part from timestamp start (integer).
   - ~raw-value:~ :: Raw timestamp (string).
   - ~repeater-type:~ :: Type of repeater, if any (symbol: ~catch-up~,
        ~restart~, ~cumulate~ or #f)
   - ~repeater-unit:~ :: Unit of shift, if a repeater is defined
        (symbol: ~year~, ~month~, ~week~, ~day~, ~hour~ or #f).
   - ~repeater-value:~ :: Value of shift, if a repeater is defined
        (integer or #f).
   - ~type:~ :: Type of timestamp (symbol: ~active~, ~active-range~,
                ~diary~, ~inactive~, ~inactive-range~).
   - ~warning-type:~ :: Type of warning, if any (symbol: ~all~,
        ~first~ or #f)
   - ~warning-unit:~ :: Unit of delay, if one is defined (symbol:
        ~year~, ~month~, ~week~, ~day~, ~hour~ or #f).
   - ~warning-value:~ :: Value of delay, if one is defined (integer or
        #f).
   - ~year-end:~ :: Year part from timestamp end.  If no ending date
                    is defined, it defaults to start year part
                    (integer).
   - ~year-start:~ :: Year part from timestamp start (integer).

#+begin_src gerbil
  (def (timestamp-parser)
    (def (stamp-type stamp)
      (let* ((start (org-element-property start: stamp))
             (name (if (char=? start #\<) "active" "inactive"))
             (range (org-element-property range: stamp))
             (ts (org-element-property inner: stamp))
             (name (if (or range (org-element-property end: ts))
                     (string-append name "-range") name)))
        (string->symbol name)))
    (def (repeater/warning-type r)
     ;; MARK is ~+~ (cumulate type), ~++~ (catch-up type) or ~.+~ (restart type)
     ;; for a repeater, and ~-~ (all type) or ~--~ (first type) for warning
     ;; delays.
      (case (string->symbol (org-element-property m: r))
        ((+) 'cumulate) ((++) 'catch-up) ((.+) 'restart)
        ((-) 'all) ((--) 'first)))

    (def (warning? r)
      (and r (member (repeater/warning-type r) '(all first))))
    (def (repeater? r)
      (and r (not (warning? r))))

    (def (rep/warn-props r)
      (def name (if (warning? r) "warning-" "repeater-"))
      (def (key n) (string->keyword (string-append name n)))

      (if (not r) []
          (list (key "type") (repeater/warning-type r)
                ;; UNIT is a character among ~h~ (hour), ~d~ (day), ~w~ (week),
                ;; ~m~ (month), ~y~ (year).
                (key "unit") (case (string->symbol
                                    (string (org-element-property u: r)))
                               ((h) 'hour) ((d) 'day) ((w) 'week)
                               ((m) 'month) ((y) 'year))
                (key "value") (org-element-property v: r))))


    (.let* ((b (point)) (stamp TIMESTAMP) (e (point))
            (raw-value (buffer-substring b e)))
     (let* ((ts (org-element-property inner: stamp))
            (type (stamp-type stamp))
            (sd (org-element-property date: ts))
            (ys (org-element-property y: sd))
            (mos (org-element-property m: sd)) 
            (ds (org-element-property d: sd)) 
            (st (org-element-property start: ts)) 
            (hs (and st (org-element-property h: st)))
            (mis (and st (org-element-property m: st)))
            (range (org-element-property range: stamp))
            (rts (and range (org-element-property inner: range)))
            (et (or (and rts (org-element-property start: rts))
                    (org-element-property end: ts)
                    st))         
            (range (if rts (org-element-property date: rts) sd))
            (ye (org-element-property y: range)) 
            (moe (org-element-property m: range))
            (de (org-element-property d: range))
            (he (and et (org-element-property h: et)))
            (mie (and et (org-element-property m: et)))
            (rep/warn (list  (org-element-property repeat: ts)
                              (org-element-property warn: ts)
                              (and rts (org-element-property repeat: rts))
                              (and rts (org-element-property warn: rts))))
            (repeater (find repeater? rep/warn))
            (warning (find warning? rep/warn))
            (r/w-props (append (rep/warn-props repeater)
                               (rep/warn-props warning))))
       ['timestamp  (cons* type: type raw-value: raw-value
                          year-start: ys month-start: mos day-start: ds
                          hour-start: hs minute-start: mis

                          year-end: ye month-end: moe day-end: de
                          hour-end: he minute-end: mie
                          begin: b end: e post-blank: 0

                          r/w-props)])))








#+end_src

** DONE Underline                                           :RecursiveObject:
   CLOSED: [2019-11-16 Sat 23:28]

   Recursive object.

   No _specific_ property.

   #+begin_src gerbil :noweb-ref emphasis-objects
  (def (underline-parser)
    (.begin (peek #\_) (emphasis-parser)))
   #+end_src
** Verbatim

   =Object.=

   - ~:value~ :: Contents (string).

   #+begin_src gerbil :noweb-ref emphasis-objects
  (def (verbatim-parser)
    (.begin (peek #\=) (emphasis-parser)))
   #+end_src

** Verse Block

   Element containing objects.

   No specific property.

* Other Tools
  :PROPERTIES:
  :CUSTOM_ID:       other-tools
  :END:

** Turning an AST into an Org document

   ~interpret-data~ is the reciprocal operation of
   ~parse-buffer~.  When provided an element, object, or
   even a full parse tree, it generates an equivalent string in Org
   syntax.

   More precisely, output is a normalized document: it preserves
   structure and blank spaces but it removes indentation and
   capitalize keywords.  As a consequence it is equivalent, but not
   equal, to the original document the AST comes from.

   When called on an element or object obtained through
   ~at-point~ or ~context~, its contents will
   not appear, since this information is not available.



** Examining genealogy of an element or object

   ~org-element-lineage~ produces a list of all ancestors of a given
   element or object.  However, when these come from a local parsing
   function, lineage is limited to the section containing them.

   With optional arguments, it is also possible to check for
   a particular type of ancestor.  See function's docstring for more
   information.


* Test it all out


#+begin_src gerbil :noweb yes :tangle "test-element.ss" 
  (import :drewc/org/element :drewc/org/syntax :drewc/org/location
          :drewc/smug :std/misc/ports :std/srfi/1 :std/misc/list
          :std/iter :std/sugar :std/srfi/13 :std/test)

  <<headline-test>>

#+end_src


* /file/ element.ss

#+begin_src gerbil :noweb yes :tangle element.ss
  ;; (c) drewc <me@drewc.ca> All Rights Reserved
  (import :drewc/smug 
          :drewc/org/syntax :drewc/org/environment :drewc/org/location
          :std/srfi/13 :std/srfi/1 :gerbil/gambit/exact :std/misc/list :std/iter)
  (export #t)

  <<element-descriptions>>

  <<plain-text>>

  <<element-accessors>>

  <<setters-code>>

  <<take-post-blank>>


  ;; * Affiliated Keywords

  ;; Each element can optionally get some more from affiliated keywords, namely:
  ;; ~caption:~, ~header:~, ~name:~, ~plot:~, ~results:~ or ~attr_NAME:~ where
  ;; =NAME= stands for the name of an export back-end.

  <<affiliated-keywords>>

  <<table-parser>>

  <<timestamp-element>>

  <<headline-element>>

  <<section-parser>>

  <<snapshot>>

  <<paragraph-parser>>

  <<emphasis-parser>>

  <<emphasis-objects>>
#+end_src

* Copyright

Documentation from the orgmode.org/worg/ website (either in its HTML format or
in its Org format) is licensed under the GNU Free Documentation License version
1.3 or later

Copyright (C) 2019 Drew Crampsie.
    Permission is granted to copy, distribute and/or modify this document
    under the terms of the GNU Free Documentation License, Version 1.3
    or any later version published by the Free Software Foundation;
    with no Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts.
    A copy of the license is included in the section entitled "GNU
    Free Documentation License".


** History 

#+begin_src org
#+end_src

* Footnotes

[fn:1] Thus, ~at-point~ cannot return the parent of
a headline.  Nevertheless, headlines are context free elements: it is
efficient to move to parent headline (e.g., with
~org-up-heading-safe~) before analyzing it.

[fn:2] As a consequence whitespaces or newlines after an element or
object still belong to it.  To put it differently, ~:end~ property of
an element matches ~:begin~ property of the following one at the same
level, if any.
