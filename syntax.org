#+TITLE: Org Syntax
#+AUTHOR: Drew Crampsie
#+OPTIONS: toc:t ':t author:nil
#+LANGUAGE: en
#+BIND: sentence-end-double-space t

#+TODO: TODO STARTED | DONE

This document describes and implements Org syntax as it is currently read by its
parser (Org Elements) and, therefore, by the export framework.  It also includes
a few comments on that syntax.

A core concept in this syntax is that only headlines, sections, planning lines
and property drawers are context-free[fn:1][fn:2].  Every other syntactical part
only exists within specific environments.

#+begin_src gerbil
  (import :drewc/smug :drewc/org/environment)
#+end_src

Three categories are used to classify these environments: "Greater
elements", "elements", and "objects", from the broadest scope to the
narrowest.  The word "element" is used for both Greater and non-Greater
elements, the context should make that clear.

The paragraph is the unit of measurement.  An element defines
syntactical parts that are at the same level as a paragraph,
i.e. which cannot contain or be included in a paragraph.  An object is
a part that could be included in an element.  Greater elements are all
parts that can contain an element.

Empty lines belong to the largest element ending before them.  For
example, in a list, empty lines between items belong are part of the
item before them, but empty lines at the end of a list belong to the
plain list element.

Unless specified otherwise, case is not significant.

#+NAME: ANY-STRING
#+begin_src gerbil
  (def (ANY-STRING . strings)
    (apply .or (map (cut .string-ci=? <>) strings)))
#+end_src

* Global Definitions
  :PROPERTIES:
  :header-args: :noweb-ref global
  :END:

** EOF 

  Though ~(.not (item))~ is also a way to say "this is the end of what we're
  parsing", ~EOF~ is shorter and sweeter.

#+begin_src gerbil
  (def EOF (.begin (.not (item)) (return #!eof)))
#+end_src

** Whitespace


 We often want whitespace that is not a newline.

 #+NAME: WS
 #+begin_src gerbil
   (def WS (sat (? (and char-whitespace? (not (cut char=? #\newline <>))))))
 #+end_src

** Lines

#+begin_src gerbil
  (def BOL
    (.let* (p (point))
      (if (zero? p) (return #t) (peek (.begin (goto-char (- p 1)) #\newline)))))
#+end_src
 
We often want to know if it's the end of line. But, the EOF is also EOL.

#+NAME: EOL
 #+begin_src gerbil
  (def EOL (.or #\newline EOF))
 #+end_src

 We only want to skip the last line once because otherwise ~some~ and ~many~
 will recursively go on for many years. Don't ask me how I know.

  #+NAME: SKIP-LINE
  #+begin_src gerbil
    (def SKIP-LINE
      (let (S (sat (? (not (cut char=? <> #\newline)))))
         (.or (.begin (skip S) (sat (cut char=? #\newline <>)))
              (.begin (many1 S) EOF (return #!eof)))))
  #+end_src

** Optional

 Some things are optional.
 #+NAME: OPT
 #+begin_src gerbil
   (def (OPT p) (.or p (return #f)))
 #+end_src

** Rtrim

 Whitespace often comes at the end.

#+begin_src gerbil
  (def RTRIM (cut .begin0 <> (skip WS)))
#+end_src

* STARTED Headlines and Sections
  :PROPERTIES:
  :CUSTOM_ID: Headlines_and_Sections
  :header-args: :noweb-ref headlines-and-sections
  :END:
  
  A headline is defined as:

  #+BEGIN_EXAMPLE
  STARS KEYWORD PRIORITY TITLE TAGS
  #+END_EXAMPLE


  #+begin_src gerbil :noweb-ref headline
    (def (HEADLINE (min-depth 1))
      (.let* ((s (STARS min-depth)) (k TODO-KEYWORD) (p PRIORITY)
              (c COMMENT)
              (title TITLE) (tags (.or (.begin0 TAGS (skip WS) EOL)
                                       (.begin EOL #f))))
        ['headline (list stars: s todo-keyword: k priority: p
                         title: (list->string title) tags: tags
                         commented?: c footnote-section?: (footnote-section? title)
                         archived?: (archived? tags))]))
  #+end_src
  
  STARS is a string starting at column 0, containing at least one
  asterisk (and up to ~org-inlinetask-min-level~ if =org-inlinetask=
  library is loaded) and ended by a space character.  The number of
  asterisks is used to define the level of the headline.  It's the
  sole compulsory part of a headline.

#+begin_src gerbil
  (def STARS-ONLY (.begin0 (many1 #\*) #\space))
#+end_src
  
  A headline element can contain a deeper level headline element, so we'll add a
  test.
  
 #+begin_src gerbil
   (def (STARS (min-depth 1))
    (RTRIM (sat (lambda (stars) (>= (length stars) min-depth)) STARS-ONLY)))
  #+end_src

  KEYWORD is a TODO keyword, which has to belong to the list defined
  in ~org-todo-keywords-1~.  Case is significant.

#+begin_src gerbil
  (def TODO-KEYWORD (OPT (RTRIM (apply .or (org-env-ref 'org-todo-keywords-1)))))
#+end_src

  PRIORITY is a priority cookie, i.e. a single letter preceded by
  a hash sign # and enclosed within square brackets.

#+begin_src gerbil
  (def PRIORITY (OPT (RTRIM (bracket "[#" (sat char-alphabetic?) "]"))))
#+end_src

  TITLE can be made of any character but a new line.  Though, it will
  match after every other part have been matched. 

#+begin_src gerbil
  (def TITLE (some (sat (? (not (cut char=? <> #\newline))))))
#+end_src

  TAGS is made of words containing any alpha-numeric character,
  underscore, at sign, hash sign or percent sign, and separated with
  colons.

#+begin_src gerbil
  (def TAG
    ((liftP list->string)
     (many1 (.or (sat char-alphabetic?) (sat char-numeric?) #\_ #\@ #\# #\%))))

  (def TAGS (RTRIM (OPT (bracket " :" (sepby1 TAG ":") ":"))))
#+end_src
  
  Examples of valid headlines include:

  #+BEGIN_EXAMPLE
  ,*

  ,** DONE

  ,*** Some e-mail

  ,**** TODO [#A] COMMENT Title :tag:a2%:
  #+END_EXAMPLE
    
  If the first word appearing in the title is "COMMENT", the headline will be
  considered as "commented".  We'll return the point as the element parser wants
  to know where title starts.

Case is significant.

  #+begin_src gerbil
    (def COMMENT 
      (.or (.begin "COMMENT" (.or " " EOL) (skip WS) (return #t))
                    (return #f)))
  #+end_src

  If its title is ~org-footnote-section~, it will be considered as
  a "footnote section".  Case is significant. 

 #+begin_src gerbil
   (def (footnote-section? title)
     (string=? (org-env-ref 'org-footnote-section) (list->string title))) 
 #+end_src

  If ~org-archive-tag~ is one of its tags, it will be considered as
  "archived".  Case is significant.

#+begin_src gerbil
  (def (archived? tags)
    (if (and tags (member (org-env-ref 'org-archive-tag) tags)) #t #f))
#+end_src


  A headline contains directly one section (optionally), followed by
  any number of deeper level headlines.


  #+begin_src gerbil
    (def (HEADLINE-ELEMENT min-depth: (min-depth 1) section: (sect (.read-line)))
      (.let* ((headline (HEADLINE min-depth))
              (section (.begin0 (some sect) (.or (peek STARS-ONLY) (.not (item)))))
              (subs (many (HEADLINE-ELEMENT min-depth: (1+ min-depth)
                                             section: sect))))
       (cons 'headline (append headline [section: (append section subs)]))))
  #+end_src
  
  A section contains directly any greater element or element.  Only
  a headline can contain a section.  As an exception, text before the
  first headline in the document also belongs to a section.

  As an example, consider the following document:

  #+BEGIN_SRC org :noweb-ref nil
    An introduction.

    ,* A Headline 

      Some text.

    ,** Sub-Topic 1

    ,** Sub-Topic 2

    ,*** Additional entry 
  #+END_SRC

  Its internal structure could be summarized as:

  #+BEGIN_EXAMPLE
  (document
   (section)
   (headline
    (section)
    (headline)
    (headline
     (headline))))
  #+END_EXAMPLE

Test time.


  
* STARTED Affiliated Keywords
  :PROPERTIES:
  :CUSTOM_ID: Affiliated_keywords
  :header-args: :noweb-ref affiliated-keywords
  :END:

  With the exception of clocks, headlines, inlinetasks, items, node
  properties, planning, property drawers, sections, and table rows,
  every other element type can be assigned attributes.

  This is done by adding specific keywords, named "affiliated
  keywords", just above the element considered, no blank line
  allowed.

  Affiliated keywords are built upon one of the following patterns:

  #+begin_example
    ,#+KEY: VALUE
    ,#+KEY[OPTIONAL]: VALUE
    ,#+ATTR_BACKEND: VALUE
  #+end_example

 #+begin_src gerbil :noweb-ref "afk"
   (def (AFFILIATED-KEYWORD (keyword KEY))
     (.let* ((key (.begin "#+" (.or keyword ATTR_BACKEND)))
             (opt OPTIONAL) (_ ": ") (val VALUE) (_ EOL))
            ['affiliated-keyword
             (list key: key option: (if (or (not opt) (null? opt)) #f
                                        (list->string opt))
                   value: (list->string val))
             ]))
#+end_src
  
  KEY is either "CAPTION", "HEADER", "NAME", "PLOT" or "RESULTS"
  string.

#+begin_src gerbil
  (def KEY (ANY-STRING "CAPTION" "HEADER" "NAME" "PLOT" "RESULTS"))
#+end_src

  BACKEND is a string constituted of alpha-numeric characters, hyphens
  or underscores.

#+begin_src gerbil
  (def BACKEND
    (some1 (.or (sat char-alphabetic?) (sat char-numeric?) #\- #\_)))

  (def ATTR_BACKEND (.let* ((a (.string-ci=? "ATTR_")) (b BACKEND))
                      (string-append a (list->string b))))
#+end_src

  OPTIONAL and VALUE can contain any character but a new line.  Only
  "CAPTION" and "RESULTS" keywords can have an optional value.

#+begin_src gerbil
  (def NO-EOL (sat (? (not (cut char=? #\newline <>)))))
  (def OPTIONAL (OPT (bracket #\[ (some1 NO-EOL) #\])))
  (def VALUE (OPT (some1 NO-EOL)))
#+end_src

  An affiliated keyword can appear more than once if KEY is either
  "CAPTION" or "HEADER" or if its pattern is "#+ATTR_BACKEND: VALUE".

  "CAPTION", "AUTHOR", "DATE" and "TITLE" keywords can contain objects
  in their value and their optional value, if applicable.

* STARTED Greater Elements
  :PROPERTIES:
  :CUSTOM_ID: Greater_Elements
  :END:

  Unless specified otherwise, greater elements can contain directly
  any other element or greater element excepted:

  - elements of their own type,
  - node properties, which can only be found in property drawers,
  - items, which can only be found in plain lists.

** STARTED Greater Blocks
   :PROPERTIES:
   :CUSTOM_ID: Greater_Blocks
   :header-args: :noweb-ref greater-blocks 
   :END:

   Greater blocks consist in the following pattern:

   #+BEGIN_EXAMPLE
     ,#+BEGIN_NAME PARAMETERS
     CONTENTS
     ,#+END_NAME
   #+END_EXAMPLE

#+begin_src gerbil
 (def GREATER-BLOCK 
    (.let* ((name BEGIN_NAME) (data (DATA name)) 
                (value (CONTENTS name)) (_ SKIP-LINE))
      [(string->symbol (string-append (string-downcase name) "-block"))
       value: (string-trim-right value)])
#+end_src
   
NAME can contain any non-whitespace character.

#+begin_src gerbil :noweb-ref all-blocks
  (def NAME ((liftP list->string) (many1 (sat (? (not char-whitespace?))))))
#+end_src

   PARAMETERS can contain any character other than new line, and can
   be omitted.

   If NAME is "CENTER", it will be a "center block".  If it is
   "QUOTE", it will be a "quote block".

   If the block is neither a center block, a quote block or a [[#Blocks][block element]]
    it will be a "special block".

   CONTENTS can contain any element, except : a line =#+END_NAME= on
   its own.  Also lines beginning with STARS must be quoted by
   a comma.

** STARTED Drawers and Property Drawers
   :PROPERTIES:
   :CUSTOM_ID: Drawers
   :header-args: :noweb-ref drawers-code
   :END:

   Pattern for drawers is:

   #+BEGIN_EXAMPLE
   :NAME:
   CONTENTS
   :END:
   #+END_EXAMPLE

   NAME can contain word-constituent characters, hyphens and
   underscores.

#+begin_src gerbil
  (def (DRAWER-DELIMITER p)
    (bracket (.begin (skip WS) #\:) p (.begin #\: (skip WS) EOL)))

  (def DRAWER-START
    ((liftP list->string)
     (DRAWER-DELIMITER
      (many1 (.or (sat (? (or char-alphabetic? char-numeric?))) #\_ #\-)))))

  (def DRAWER-END
    (DRAWER-DELIMITER "END"))
#+end_src

   CONTENTS can contain any element but another drawer.


** Dynamic Blocks
   :PROPERTIES:
   :CUSTOM_ID: Dynamic_Blocks
   :END:

   Pattern for dynamic blocks is:

   #+BEGIN_EXAMPLE
   ,#+BEGIN: NAME PARAMETERS
   CONTENTS
   ,#+END:
   #+END_EXAMPLE

   NAME cannot contain any whitespace character.

   PARAMETERS can contain any character and can be omitted.

** Footnote Definitions
   :PROPERTIES:
   :CUSTOM_ID: Footnote_Definitions
   :END:

   Pattern for footnote definitions is:

   #+BEGIN_EXAMPLE
   [fn:LABEL] CONTENTS
   #+END_EXAMPLE

   It must start at column 0.

   LABEL is either a number or follows the pattern "fn:WORD", where
   word can contain any word-constituent character, hyphens and
   underscore characters.

   CONTENTS can contain any element excepted another footnote
   definition.  It ends at the next footnote definition, the next
   headline, two consecutive empty lines or the end of buffer.

** Inlinetasks
   :PROPERTIES:
   :CUSTOM_ID: Inlinetasks
   :END:

   Inlinetasks are defined by ~org-inlinetask-min-level~ contiguous
   asterisk characters starting at column 0, followed by a whitespace
   character.

   Optionally, inlinetasks can be ended with a string constituted of
   ~org-inlinetask-min-level~ contiguous asterisk characters starting
   at column 0, followed by a space and the "END" string.

   Inlinetasks are recognized only after =org-inlinetask= library is
   loaded.

** Plain Lists and Items
   :PROPERTIES:
   :CUSTOM_ID: Plain_Lists_and_Items
   :END:

   Items are defined by a line starting with the following pattern:
   "BULLET COUNTER-SET CHECK-BOX TAG", in which only BULLET is
   mandatory.

   BULLET is either an asterisk, a hyphen, a plus sign character or
   follows either the pattern "COUNTER." or "COUNTER)".  In any case,
   BULLET is follwed by a whitespace character or line ending.

   COUNTER can be a number or a single letter.

   COUNTER-SET follows the pattern [@COUNTER].

   CHECK-BOX is either a single whitespace character, a "X" character
   or a hyphen, enclosed within square brackets.

   TAG follows "TAG-TEXT ::" pattern, where TAG-TEXT can contain any
   character but a new line.

   An item ends before the next item, the first line less or equally
   indented than its starting line, or two consecutive empty lines.
   Indentation of lines within other greater elements do not count,
   neither do inlinetasks boundaries.

   A plain list is a set of consecutive items of the same indentation.
   It can only directly contain items.

   If first item in a plain list has a counter in its bullet, the
   plain list will be an "ordered plain-list".  If it contains a tag,
   it will be a "descriptive list".  Otherwise, it will be an
   "unordered list".  List types are mutually exclusive.

   For example, consider the following excerpt of an Org document:

   #+BEGIN_EXAMPLE
   1. item 1
   2. [X] item 2
      - some tag :: item 2.1
   #+END_EXAMPLE

   Its internal structure is as follows:

   #+BEGIN_EXAMPLE
   (ordered-plain-list
    (item)
    (item
     (descriptive-plain-list
      (item))))
   #+END_EXAMPLE

** DONE Property Drawers
   CLOSED: [2019-11-07 Thu 11:30]
   :PROPERTIES:
   :CUSTOM_ID: Property_Drawers
   :END:

   Property drawers are a special type of drawer containing properties
   attached to a headline.  They are located right after a headline
   and its planning information.

   #+BEGIN_EXAMPLE
   HEADLINE
   PROPERTYDRAWER

   HEADLINE
   PLANNING
   PROPERTYDRAWER
   #+END_EXAMPLE

   PROPERTYDRAWER follows the pattern

   #+BEGIN_EXAMPLE
   :PROPERTIES:
   CONTENTS
   :END:
   #+END_EXAMPLE

#+NAME: PROPERTYDRAWER
  #+begin_src gerbil
    (def PROPERTYDRAWER-START (DRAWER-DELIMITER (ci=? "PROPERTIES" #t)))
    (def PROPERTYDRAWER-END DRAWER-END)

    (def PROPERTYDRAWER
      (bind (bracket PROPERTYDRAWER-START PROPERTYDRAWER-CONTENTS PROPERTYDRAWER-END)
            (lambda (c) (return ['property-drawer [] . c]))))
  #+end_src

   CONTENTS consists of zero or more [[#Node_Properties][Node Properties]].

#+NAME: PROPERTYDRAWER-CONTENTS
#+begin_src gerbil
    (def PROPERTYDRAWER-CONTENTS (some NODE-PROPERTY))
#+end_src

** Tables
   :PROPERTIES:
   :CUSTOM_ID: Tables
   :header-args: :noweb-ref table-parser
   :END:

   Tables start at lines beginning with either a vertical bar or the
   "+-" string followed by plus or minus signs only, assuming they are
   not preceded with lines of the same type.  These lines can be
   indented.

   A table starting with a vertical bar has "org" type.  Otherwise it
   has "table.el" type.

#+begin_src gerbil
  (def TABLE-ELEMENT-ROW
    (bracket (skip WS) TABLE-ROW (.begin (skip WS) EOL)))
  (def TABLE
    (.let* ((cb (point))(spaces (many WS)) (rows (many1 TABLE-ELEMENT-ROW))
            (ce (point)) (formulas (.or (many1 TBLFM) #f)))
      ['table [type: 'org spaces: spaces contents-begin: cb contents-end: ce contents: rows tblfm: formulas]]))
#+end_src

   Org tables end at the first line not starting with a vertical bar.
   Table.el tables end at the first line not starting with either
   a vertical line or a plus sign.  Such lines can be indented.

   An org table can only contain table rows.  A table.el table does
   not contain anything.

   One or more "#+TBLFM: FORMULAS" lines, where "FORMULAS" can contain
   any character, can follow an org table.

#+begin_src gerbil :noweb-ref table-fm
  (def TBLFM (.begin (skip WS) "#+TBLFM: " (.read-line include-newline?: #f)))
#+end_src

*** TODO  Support table.el tables
* STARTED Elements
  :PROPERTIES:
  :CUSTOM_ID: Elements
  :END:

  Elements cannot contain any other element.

  Only keywords whose name belongs to
  ~org-element-document-properties~, verse blocks , paragraphs and
  table rows can contain objects.

** Babel Call
   :PROPERTIES:
   :CUSTOM_ID: Babel_Call
   :END:

   Pattern for babel calls is:

   #+BEGIN_EXAMPLE
   ,#+CALL: VALUE
   #+END_EXAMPLE

   VALUE is optional.  It can contain any character but a new line.

** Blocks
   :PROPERTIES:
   :CUSTOM_ID: Blocks
   :header-args: :noweb-ref blocks-code
   :END:

   Like greater blocks, pattern for blocks is:

   #+BEGIN_EXAMPLE
   ,#+BEGIN_NAME DATA
   CONTENTS
   ,#+END_NAME
   #+END_EXAMPLE

#+begin_src gerbil
  (def BLOCK 
    (.let* ((name BEGIN_NAME) (data (DATA name)) 
                (value (CONTENTS name)) (_ SKIP-LINE))
      [(string->symbol (string-append (string-downcase name) "-block"))
       value: (string-trim-right value)]))
#+end_src

   NAME cannot contain any whitespace character.


#+begin_src gerbil 
  (def NAME ((liftP list->string) (many1 (sat (? (not char-whitespace?))))))
#+end_src
   If NAME is "COMMENT", it will be a "comment block".  If it is
   "EXAMPLE", it will be an "example block".  If it is "EXPORT", it
   will be an "export block".  If it is "SRC", it will be a "source
   block".  If it is "VERSE", it will be a "verse block".

#+begin_src gerbil
  (def BLOCK-ELEMENT-NAME (sat (cut member <> '("COMMENT" "EXAMPLE" "EXPORT" "SRC" "VERSE")
                                    string-ci=?)))
  (def BEGIN_NAME
    (.begin (.string-ci=? "#+BEGIN_")
              ))

  (def (END_NAME name)
    (.let* ((name (.begin (.string-ci=? "#+END_") (.string-ci=? name)))
                (_ (peek (sat char-whitespace?))))
       name))

#+end_src

   CONTENTS can contain any character, including new lines. Though it will only
   contain Org objects if the block is a verse block. Otherwise, CONTENTS will
   not be parsed.

#+begin_src gerbil
  (def (CONTENTS name)
    (let lines ((ls []))
      (.let* (l (.or (.begin (END_NAME name) (return #t))
                             (.read-line)))
                 (if (eq? #t l)
                   (return (string-concatenate (reverse! ls)))
                   (lines (cons l ls))))))
#+end_src
   
   DATA can contain any character but a new line.  It can be omitted,
   unless the block is either a "source block" or an "export block".

#+begin_src gerbil
  (def (DATA name)
    (case (string->symbol (string-downcase name))
      ((export) EXPORT-DATA)
      ((src) SRC-DATA)
      (else (.read-line))))
#+end_src

   In the latter case, it should be constituted of a single word.

#+begin_src gerbil 
  (def EXPORT-DATA (.let* ((_ (skip WS))
                              (type ((liftP list->string)
                                     (many1 (sat (? (not char-whitespace?))))))
                              (_ SKIP-LINE))
                     type))
#+end_src
   
   In the former case, it must follow the pattern "LANGUAGE SWITCHES
   PARAMETERS", where SWITCHES and PARAMETERS are optional.

#+begin_src gerbil
  (def SRC-DATA 
   (.let* ((_ (skip WS)) (l LANGUAGE)
               (_ (skip WS)) (s (OPT SWITCHES))
               (_ (skip WS)) (p (OPT PARAMETERS)) (_ SKIP-LINE))
     [language: l switches: s parameters: p]))
#+end_src

   LANGUAGE cannot contain any whitespace character.

#+begin_src gerbil
  (def LANGUAGE
    ((liftP list->string) (many (sat (? (not char-whitespace?))))))
#+end_src

    SWITCHES is made of any number of "SWITCH" patterns, separated by
    blanks.

#+begin_src gerbil
  (def SWITCHES
    (.or (sepby1
              (.or SWITCH-r
                              SWITCH-l
                              SWITCH-n
                              SWITCH-i)
              (skip WS))
             (return #f)))

#+end_src

#+begin_src gerbil
  (def SWITCH (.let* ((sign (.or #\+ #\-)) (letter (sat char-alphabetic?)))
                (values sign letter)))
#+end_src
 
 - -n [arg] :: "Both in ‘example’ and in ‘src’ snippets, you can add a ‘-n’ switch
          [...] ‘-n’ takes an optional numeric argument specifying the starting
          line number of the block. [...] use a ‘+n’ switch, [...] can also take
          a numeric argument[fn:ol]"

          #+begin_src gerbil
            (def SWITCH-n
              (.let* (((values sign letter) SWITCH)
                          (arg (if (not (char=? #\n letter)) (fail)
                                   (OPT (.begin " " (skip WS)
                                                  ((liftP (lambda (lst)
                                                            (string->number (list->string lst))))
                                                   (at-least 1 (sat char-numeric?))))))))
                         ['switch letter: letter sign: sign arg: arg]))
          #+end_src

  - -r :: "You can also add a ‘-r’ switch which removes the labels from the
          source code[fn:ol]"

  - -i :: "preserve the indentation of a specific code block[fn:ol]"

          #+begin_src gerbil
            (def (SWITCH-char char)
              (.let* (((values s l) SWITCH))
               (if (and (char=? l char) (char=? #\- s))
                 ['switch letter: l sign: s])))

            (def SWITCH-r (SWITCH-char #\r))
            (def SWITCH-i (SWITCH-char #\i))
          #+end_src

  
  - -l arg :: "If the syntax for the label format conflicts with the language syntax,
          use a ‘-l’ switch to change the format, for example :
          src_org{#+BEGIN_SRC pascal -n -r -l "((%s))"}[fn:ol]"

          FORMAT can contain any character but a double quote and a new line

        #+begin_src gerbil
  (def FORMAT
    (.begin #\"
              (.begin0 ((liftP list->string)
                            (many (sat (? (not (cut member <> '(#\" #\newline)))))))
                           #\")))

  (def SWITCH-l
    (.let* (((values sign letter) SWITCH)
                (format (if (not (char=? #\l letter)) (fail)
                         (OPT (.begin " " (skip WS)
                                        FORMAT)))))
               (return ['switch letter: letter sign: sign arg: format])))
#+end_src
   
    PARAMETERS can contain any character but a new line.
    
#+begin_src gerbil
    (def PARAMETERS
      (.or 
       ((liftP list->string) (many1 (sat (? (not (cut char=? #\newline))))))
       (return #f)))
#+end_src

** STARTED Clock, Diary Sexp and Planning
   DEADLINE: <2019-11-06 Wed> SCHEDULED: <2019-11-05 Tue>
   :PROPERTIES:
   :CUSTOM_ID: Clock,_Diary_Sexp_and_Planning
   :END:
   :LOGBOOK:
   CLOCK: [2019-11-05 Tue 13:11]--[2019-11-05 Tue 13:11] =>  0:00
   :END:

   A clock follows either of the patterns below:
   
   #+BEGIN_EXAMPLE
   CLOCK: INACTIVE-TIMESTAMP
   CLOCK: INACTIVE-TIMESTAMP-RANGE DURATION
   #+END_EXAMPLE

   INACTIVE-TIMESTAMP, resp. INACTIVE-TIMESTAMP-RANGE, is an inactive,
   resp. inactive range, timestamp object.

   DURATION follows the pattern:

   #+BEGIN_EXAMPLE
   => HH:MM
   #+END_EXAMPLE

   HH is a number containing any number of digits.  MM is a two digit
   numbers.

   A diary sexp is a line starting at column 0 with "%%(" string.  It
   can then contain any character besides a new line.

   A planning is an element with the following pattern:

   #+BEGIN_EXAMPLE
   HEADLINE
   PLANNING
   #+END_EXAMPLE
   
    #+NAME: PLANNING
   #+begin_src gerbil 
      (def (PLANNING (ts TIMESTAMP))
        (def plan (.let* ((k PLANNING-KEYWORD)
                          (t (.begin (skip WS) ts)))
                    [(string->keyword (string-downcase k))  t]))
        (.let* ((plans (many1 plan))
                (_ (.begin (skip WS) EOL)))
          (apply append plans)))
   #+end_src
   
   HEADLINE is a headline element and PLANNING is a line filled
   with INFO parts, where each of them follows the pattern:

   #+BEGIN_EXAMPLE
   KEYWORD: TIMESTAMP
   #+END_EXAMPLE

   KEYWORD is either "DEADLINE", "SCHEDULED" or "CLOSED".  TIMESTAMP
   is a timestamp object.

#+NAME: PLANNING-KEYWORD 
#+begin_src gerbil
  (def PLANNING-KEYWORD
    (bracket (skip WS)
             (.or (ci=? "DEADLINE") (ci=? "SCHEDULED") (ci=? "CLOSED"))
             ": "))
#+end_src

   In particular, no blank line is allowed between PLANNING and
   HEADLINE.

** Comments
   :PROPERTIES:
   :CUSTOM_ID: Comments
   :END:

   A "comment line" starts with a hash signe and a whitespace
   character or an end of line.

   Comments can contain any number of consecutive comment lines.

** Fixed Width Areas
   :PROPERTIES:
   :CUSTOM_ID: Fixed_Width_Areas
   :END:

   A "fixed-width line" start with a colon character and a whitespace
   or an end of line.

   Fixed width areas can contain any number of consecutive fixed-width
   lines.

** Horizontal Rules
   :PROPERTIES:
   :CUSTOM_ID: Horizontal_Rules
   :END:

   A horizontal rule is a line made of at least 5 consecutive hyphens.
   It can be indented.

** Keywords
   :PROPERTIES:
   :CUSTOM_ID: Keywords
   :END:

   Keywords follow the syntax:

   #+BEGIN_EXAMPLE
   ,#+KEY: VALUE
   #+END_EXAMPLE

   KEY can contain any non-whitespace character, but it cannot be
   equal to "CALL" or any affiliated keyword.

   VALUE can contain any character excepted a new line.

   If KEY belongs to ~org-element-document-properties~, VALUE can
   contain objects.

** LaTeX Environments
   :PROPERTIES:
   :CUSTOM_ID: LaTeX_Environments
   :END:

   Pattern for LaTeX environments is:

   #+BEGIN_EXAMPLE
   \begin{NAME} CONTENTS \end{NAME}
   #+END_EXAMPLE

   NAME is constituted of alpha-numeric or asterisk characters.

   CONTENTS can contain anything but the "\end{NAME}" string.

** Node Properties
   :PROPERTIES:
   :CUSTOM_ID: Node_Properties
   :END:

   Node properties can only exist in property drawers.  Their pattern
   is any of the following

   #+BEGIN_EXAMPLE
   :NAME: VALUE

   :NAME+: VALUE

   :NAME:

   :NAME+:
   #+END_EXAMPLE

   NAME can contain any non-whitespace character but cannot end with
   a plus sign.  It cannot be the empty string.

   VALUE can contain anything but a newline character.

#+NAME: node-property
#+begin_src gerbil 
  (def NODE-PROPERTY
    (.let* ((k (bracket (.begin (skip WS) #\:) (some1 (sat (? (not char-whitespace?)))) #\:))
            (v (bracket (skip WS) (some (sat (? (not (cut char=? <> #\newline))))) EOL)))
     ['node-property [key: (list->string k) value: (list->string v)]]))
#+end_src

** Paragraphs
   :PROPERTIES:
   :CUSTOM_ID: Paragraphs
   :END:

   Paragraphs are the default element, which means that any
   unrecognized context is a paragraph.

   Empty lines and other elements end paragraphs.

   Paragraphs can contain every type of object.

** Table Rows
   :PROPERTIES:
   :CUSTOM_ID: Table_Rows
   :END:

   A table rows is either constituted of a vertical bar and any number
   of table cells or a vertical bar followed by a hyphen.

   | table row | the next is rule |
   |-----------+------------------|

   In the first case the table row has the "standard" type.  In the
   second case, it has the "rule" type.

    #+begin_src gerbil :noweb-ref table-row
      (def RULE-CELL
        (.let* ((contents (many #\-)) (end (.or #\+ #\|)))
               ['table-cell [type: 'rule contents: (list->string contents)]]))

      (def RULE-ROW
        (.let* (c (.begin #\| (peek #\-) (many1 RULE-CELL)))
          ['table-row [type: 'rule contents: c]]))

      (def TABLE-ROW
       (.or RULE-ROW
            (.let* (cs (.begin "|" (many TABLE-CELL)))
              ['table-row [type: 'standard contents: cs]])))
    #+end_src

   Table rows can only exist in tables.

* Objects
  :PROPERTIES:
  :CUSTOM_ID: Objects
  :END:

  Objects can only be found in the following locations:

  - affiliated keywords defined in ~org-element-parsed-keywords~,
  - document properties,
  - headline titles,
  - inlinetask titles,
  - item tags,
  - paragraphs,
  - table cells,
  - table rows, which can only contain table cell
    objects,
  - verse blocks.
    
  Most objects cannot contain objects.  Those which can will be
  specified.

** Entities and LaTeX Fragments
   :PROPERTIES:
   :CUSTOM_ID: Entities_and_LaTeX_Fragments
   :END:

   An entity follows the pattern:

   #+BEGIN_EXAMPLE
   \NAME POST
   #+END_EXAMPLE

   where NAME has a valid association in either ~org-entities~ or
   ~org-entities-user~.

   POST is the end of line, "{}" string, or a non-alphabetical
   character.  It isn't separated from NAME by a whitespace character.

   A LaTeX fragment can follow multiple patterns:

   #+BEGIN_EXAMPLE
   \NAME BRACKETS
   \(CONTENTS\)
   \[CONTENTS\]
   $$CONTENTS$$
   PRE$CHAR$POST
   PRE$BORDER1 BODY BORDER2$POST
   #+END_EXAMPLE

   NAME contains alphabetical characters only and must not have an
   association in either ~org-entities~ or ~org-entities-user~.

   BRACKETS is optional, and is not separated from NAME with white
   spaces.  It may contain any number of the following patterns:

   #+BEGIN_EXAMPLE
   [CONTENTS1]
   {CONTENTS2}
   #+END_EXAMPLE

   where CONTENTS1 can contain any characters excepted "{" "}", "["
   "]" and newline and CONTENTS2 can contain any character excepted
   "{", "}" and newline.

   CONTENTS can contain any character but cannot contain "\)" in the
   second template or "\]" in the third one.

   PRE is either the beginning of line or a character different from
   ~$~.

   CHAR is a non-whitespace character different from ~.~, ~,~, ~?~,
   ~;~, ~'~ or a double quote.

   POST is any punctuation (including parentheses and quotes) or space
   character, or the end of line.

   BORDER1 is a non-whitespace character different from ~.~, ~,~, ~;~
   and ~$~.

   BODY can contain any character excepted ~$~, and may not span over
   more than 3 lines.

   BORDER2 is any non-whitespace character different from ~,~, ~.~ and
   ~$~.

   #+ATTR_ASCII: :width 5
   -----

   #+BEGIN_QUOTE
   It would introduce incompatibilities with previous Org versions,
   but support for ~$...$~ (and for symmetry, ~$$...$$~) constructs
   ought to be removed.

   They are slow to parse, fragile, redundant and imply false
   positives.  --- ngz
   #+END_QUOTE

** Export Snippets
   :PROPERTIES:
   :CUSTOM_ID: Export_Snippets
   :END:

   Patter for export snippets is:

   #+BEGIN_EXAMPLE
   @@NAME:VALUE@@
   #+END_EXAMPLE

   NAME can contain any alpha-numeric character and hyphens.

   VALUE can contain anything but "@@" string.

** Footnote References
   :PROPERTIES:
   :CUSTOM_ID: Footnote_References
   :END:

   There are four patterns for footnote references:

   #+BEGIN_EXAMPLE
   [fn:LABEL]
   [fn:LABEL:DEFINITION]
   [fn::DEFINITION]
   #+END_EXAMPLE

   LABEL can contain any word constituent character, hyphens and
   underscores.

   DEFINITION can contain any character.  Though opening and closing
   square brackets must be balanced in it.  It can contain any object
   encountered in a paragraph, even other footnote references.

   If the reference follows the second pattern, it is called an
   "inline footnote".  If it follows the third one, i.e. if LABEL is
   omitted, it is an "anonymous footnote".

** Inline Babel Calls and Source Blocks
   :PROPERTIES:
   :CUSTOM_ID: Inline_Babel_Calls_and_Source_Blocks
   :END:

   Inline Babel calls follow any of the following patterns:

   #+BEGIN_EXAMPLE
   call_NAME(ARGUMENTS)
   call_NAME[HEADER](ARGUMENTS)[HEADER]
   #+END_EXAMPLE

   NAME can contain any character besides ~(~, ~)~ and "\n".

   HEADER can contain any character besides ~]~ and "\n".

   ARGUMENTS can contain any character besides ~)~ and "\n".

   Inline source blocks follow any of the following patterns:
   
   #+BEGIN_EXAMPLE
   src_LANG{BODY}
   src_LANG[OPTIONS]{BODY}
   #+END_EXAMPLE

   LANG can contain any non-whitespace character.

   OPTIONS and BODY can contain any character but "\n".

** Line Breaks
   :PROPERTIES:
   :CUSTOM_ID: Line_Breaks
   :END:

   A line break consists in "\\SPACE" pattern at the end of an
   otherwise non-empty line.

   SPACE can contain any number of tabs and spaces, including 0.

** Links
   :PROPERTIES:
   :CUSTOM_ID: Links
   :END:

   There are 4 major types of links:

   #+BEGIN_EXAMPLE
   PRE1 RADIO POST1          ("radio" link)
   <PROTOCOL:PATH>           ("angle" link)
   PRE2 PROTOCOL:PATH2 POST2 ("plain" link)
   [[PATH3]DESCRIPTION]      ("regular" link)
   #+END_EXAMPLE

   PRE1 and POST1, when they exist, are non alphanumeric characters.

   RADIO is a string matched by some radio target.  It may contain
   entities, latex fragments, subscript and superscript.

   PROTOCOL is a string among ~org-link-types~.

   PATH can contain any character but ~]~, ~<~, ~>~ and ~\n~.

   PRE2 and POST2, when they exist, are non word constituent
   characters.

   PATH2 can contain any non-whitespace character excepted ~(~, ~)~,
   ~<~ and ~>~.  It must end with a word-constituent character, or any
   non-whitespace non-punctuation character followed by ~/~.

   DESCRIPTION must be enclosed within square brackets.  It can
   contain any character but square brackets.  It can contain any
   object found in a paragraph excepted a footnote reference, a radio
   target and a line break.  It cannot contain another link either,
   unless it is a plain or angular link.

   DESCRIPTION is optional.

   PATH3 is built according to the following patterns:

   #+BEGIN_EXAMPLE
   FILENAME           ("file" type)
   PROTOCOL:PATH4     ("PROTOCOL" type)
   PROTOCOL://PATH4   ("PROTOCOL" type)
   id:ID              ("id" type)
   #CUSTOM-ID         ("custom-id" type)
   (CODEREF)          ("coderef" type)
   FUZZY              ("fuzzy" type)
   #+END_EXAMPLE

   FILENAME is a file name, either absolute or relative.

   PATH4 can contain any character besides square brackets.

   ID is constituted of hexadecimal numbers separated with hyphens.

   PATH4, CUSTOM-ID, CODEREF and FUZZY can contain any character
   besides square brackets.

** Macros
   :PROPERTIES:
   :CUSTOM_ID: Macros
   :END:

   Macros follow the pattern:

   #+BEGIN_EXAMPLE
   {{{NAME(ARGUMENTS)}}}
   #+END_EXAMPLE

   NAME must start with a letter and can be followed by any number of
   alpha-numeric characters, hyphens and underscores.

   ARGUMENTS can contain anything but "}}}" string.  Values within
   ARGUMENTS are separated by commas.  Non-separating commas have to
   be escaped with a backslash character.

** Targets and Radio Targets
   :PROPERTIES:
   :CUSTOM_ID: Targets_and_Radio_Targets
   :END:

   Radio targets follow the pattern:

   #+BEGIN_EXAMPLE
   <<<CONTENTS>>>
   #+END_EXAMPLE

   CONTENTS can be any character besides ~<~, ~>~ and "\n".  It cannot
   start or end with a whitespace character.  As far as objects go, it
   can contain text markup, entities, latex fragments, subscript and
   superscript only.

   Targets follow the pattern:

   #+BEGIN_EXAMPLE
   <<TARGET>>
   #+END_EXAMPLE

   TARGET can contain any character besides ~<~, ~>~ and "\n".  It
   cannot start or end with a whitespace character.  It cannot contain
   any object.

** Statistics Cookies
   :PROPERTIES:
   :CUSTOM_ID: Statistics_Cookies
   :END:

   Statistics cookies follow either pattern:

   #+BEGIN_EXAMPLE
   [PERCENT%]
   [NUM1/NUM2]
   #+END_EXAMPLE

   PERCENT, NUM1 and NUM2 are numbers or the empty string.

** Subscript and Superscript
   :PROPERTIES:
   :CUSTOM_ID: Subscript_and_Superscript
   :END:

   Pattern for subscript is:

   #+BEGIN_EXAMPLE
   CHAR_SCRIPT
   #+END_EXAMPLE

   Pattern for superscript is:

   #+BEGIN_EXAMPLE
   CHAR^SCRIPT
   #+END_EXAMPLE

   CHAR is any non-whitespace character.

   SCRIPT can be ~*~ or an expression enclosed in parenthesis
   (respectively curly brackets), possibly containing balanced
   parenthesis (respectively curly brackets).

   SCRIPT can also follow the pattern:

   #+BEGIN_EXAMPLE
   SIGN CHARS FINAL
   #+END_EXAMPLE

   SIGN is either a plus sign, a minus sign, or an empty string.

   CHARS is any number of alpha-numeric characters, commas,
   backslashes and dots, or an empty string.

   FINAL is an alpha-numeric character.

   There is no white space between SIGN, CHARS and FINAL.

** Table Cells
   :PROPERTIES:
   :CUSTOM_ID: Table_Cells
   :END:

   Table cells follow the pattern:

   #+BEGIN_EXAMPLE
   CONTENTS SPACES| 
   #+END_EXAMPLE

   | CONTENTS | can contain any character excepted a vertical bar and newline.                                        |
   | SPACES   | contains any number of space characters, including zero.  It can be used to align properly the table. |
   | FINAL    | The final bar may be replaced with a newline character for the last cell in row.                      |

#+begin_src gerbil :noweb-ref table-cells
  (def CONTENTS (some1 (sat (? (not (cut member <> '(#\| #\newline)))))))
  (def FINAL (.or #\| (peek #\newline) (.not (item))))
  (def SPACES (.or (.begin0 (many1 #\space) FINAL) (.begin FINAL (return []))))

  (def TABLE-CELL
    (.let* ((contents CONTENTS) (spaces SPACES))
      ['table-cell [contents: (list->string contents) spaces: spaces]]))
#+end_src

** Timestamps
   :PROPERTIES:
   :CUSTOM_ID: Timestamps
   :header-args: :noweb-ref timestamp-code
   :END:

   There are seven possible patterns for timestamps:
   
   #+BEGIN_EXAMPLE
   <%%(SEXP)>                                                     (diary)
   <DATE TIME REPEATER-OR-DELAY>                                  (active)
   [DATE TIME REPEATER-OR-DELAY]                                  (inactive)
   <DATE TIME REPEATER-OR-DELAY>--<DATE TIME REPEATER-OR-DELAY>   (active range)
   <DATE TIME-TIME REPEATER-OR-DELAY>                             (active range)
   [DATE TIME REPEATER-OR-DELAY]--[DATE TIME REPEATER-OR-DELAY]   (inactive range)
   [DATE TIME-TIME REPEATER-OR-DELAY]                             (inactive range)
   #+END_EXAMPLE

   There can be two REPEATER-OR-DELAY in the timestamp: one as a repeater and
   one as a warning delay. "[T]he repeater should come first and the warning
   period last"[fn:omtr]

<2001-01-01 20:00 --2h -3d>--<2002-02-02 +3m --4y>



#+begin_src gerbil :noweb-ref TIMESTAMP
  (def INNER-TIMESTAMP
    (.let* ((d DATE)
            (start (OPT (.begin " " (skip WS) TIME)))
            (end (OPT (.begin "-" TIME)))
            (rep (OPT (.begin " " (skip WS) REPEATER-OR-DELAY)))
            (wa (OPT (.begin " " (skip WS) REPEATER-OR-DELAY))))
      ['inner-timestamp [date: d start: start end: end repeat: rep warn: wa]]))

  (def TIMESTAMP
    (.let* ((b (.or #\[ #\<))
            (ts INNER-TIMESTAMP)
            (e (if (char=? #\[ b) #\] #\>))
            (range (OPT (.begin "--" (peek b) TIMESTAMP))))
    ['timestamp [start: b inner: ts range: range]]))
#+end_src

   SEXP can contain any character excepted ~>~ and ~\n~. 

      #+begin_src gerbil
        (def SEXP (some1 (sat (? (not (cut string-any <> ">\n"))))))

        (def TIMESTAMP-SEXP
          (.let* (sexp (.list->string (bracket "<%%(" SEXP ")>")))
            (string-append "(" sexp ")")))

      #+end_src

   The Org date format is inspired by the standard ISO 8601 date/time
   format. The DAYNAME is optional when you type the date yourself. However, any
   date inserted or modified by Org adds that day name.

   #+begin_src gerbil
     (def NUM (sat char-numeric?))
   #+end_src

   DATE follows the pattern:

   #+BEGIN_EXAMPLE
   YYYY-MM-DD DAYNAME
   #+END_EXAMPLE

   ~Y~, ~M~ and ~D~ are digits.  DAYNAME can contain any non
   whitespace-character besides ~+~, ~-~, ~]~, ~>~, a digit or ~\n~.

   #+begin_src gerbil
     (def DAYNAME
       (.let* (_ (skip WS))
        (.list->string (many1 (sat (? (not (or char-numeric? (cut string-any <> " +-]>\n")))))))))

     (def DATE
       (.let* ((y (.string->number (.make-string 4 NUM))) (_ #\-)
               (m (.string->number (.make-string 2 NUM))) (_ #\-)
               (d (.string->number (.make-string 2 NUM)))
               (n (OPT DAYNAME)))
       ['date [y: y m: m d: d n: n]]))

   #+end_src

   It does seem that everything after DATE is optional.

   TIME follows the pattern ~H:MM~.  ~H~ can be one or two digit long
   and can start with 0.

#+begin_src gerbil
  (def TIME
    (.let* ((h (.string->number
                (.list->string (.cons NUM (.or (.list NUM) (return []))))))
            (m (.begin #\: (.string->number (.make-string 2 NUM)))))
     ['time [h: h m: m]]))
#+end_src

   REPEATER-OR-DELAY follows the pattern:

   #+BEGIN_EXAMPLE
   MARK VALUE UNIT
   #+END_EXAMPLE

#+begin_src gerbil :noweb-ref REPEATER-OR-DELAY
  (def REPEATER-OR-DELAY
    (.let* ((m MARK) (v VALUE) (u UNIT)) ['repeater-or-delay [m: m v: v u: u]]))
#+end_src

   MARK is ~+~ (cumulate type), ~++~ (catch-up type) or ~.+~ (restart
   type) for a repeater, and ~-~ (all type) or ~--~ (first type) for
   warning delays.

#+begin_src gerbil
  (def MARK (.or "++" "+" ".+" "--" "-"))
#+end_src

   VALUE is a number.

#+begin_src gerbil
  (def VALUE (.string->number (.list->string (many1 NUM))))
#+end_src

   UNIT is a character among ~h~ (hour), ~d~ (day), ~w~ (week), ~m~
   (month), ~y~ (year).

#+begin_src gerbil
  (def UNIT (sat (cut string-any <> "hdwmy")))
#+end_src

   MARK, VALUE and UNIT are not separated by whitespace characters.



  
*** Some testing elements

** STARTED Text Markup
   :PROPERTIES:
   :CUSTOM_ID: Emphasis_Markers
   :header-args: :noweb-ref emphasis-markers
   :END:

   Text markup follows the pattern:

   #+BEGIN_EXAMPLE
   PRE MARKER CONTENTS MARKER POST
   #+END_EXAMPLE

   PRE, MARKER, CONTENTS, MARKER and POST are not separated by
   whitespace characters.

  #+begin_src gerbil :noweb-ref TEXT-MARKUP
    (def TEXT-MARKUP
      (.let* ((b (point))
              (_ (save-excursion (goto-char (1- b)) (.or (.not (item)) PRE)))
              ((values marker type) MARKER) 
              (cb (point)) (contents CONTENTS) (ce (point))

              (pb (.begin (.char=? marker) (peek (.or POST (.not (item))))
                          (skip-chars-forward " \t")))
              (end (point)))
        (cons* type (append [begin: b end: end]
                            (if (member type '(code verbatim)) 
                              [value: (list->string contents)]
                              [contents-begin: cb contents-end: ce])
                            [post-blank: pb])
               (if (member type '(code verbatim)) []
                   [(list->string contents)]))))
  #+end_src

   PRE is a whitespace character, ~(~, ~{~ ~'~ or a double quote.  It
   can also be a beginning of line.

   #+begin_src gerbil 
     (def PRE (.or (sat (? (or (cut memv <> '(#\{ #\( #\' #\"))))) WS BOL))
   #+end_src

   MARKER is a character among ~*~ (bold), ~=~ (verbatim), ~/~
   (italic), ~+~ (strike-through), ~_~ (underline), ~~~ (code).

   #+begin_src gerbil
     (def (M c s) (.begin (.char=? c) (return (values c s))))
     (def MARKER (.or (M #\* 'bold) (M #\= 'verbatim)
                      (M #\/ 'italic) (M #\+ 'strike-through)
                      (M #\_ 'underline) (M #\~ 'code)))
   #+end_src

   CONTENTS is a string following the pattern:
  
   #+BEGIN_EXAMPLE
   BORDER BODY BORDER
   #+END_EXAMPLE

   BORDER can be any non-whitespace character.
  ooi
   #+begin_src gerbil
     (def BORDER (sat (? (not char-whitespace?))))
   #+end_src
   
   BODY can contain contain any character but may not span over more
   than 3 lines.

   #+begin_src gerbil
     (def BODY
       (sat (lambda (cs) (> 2 (count (cut char=? #\newline <>) cs)))
            (some1 (item))))

   #+end_src
   
   BORDER and BODY are not separated by whitespaces.
   
   CONTENTS can contain any object encountered in a paragraph when
   markup is "bold", "italic", "strike-through" or "underline".

   CONTENTS can be anything within "code" and "verbatim" emphasis, by
   definition. Regardless, it's a string.

   #+begin_src gerbil
     (def CONTENTS
       (.let* ((bb BORDER) (b BODY) (be BORDER))
         (set! (cdr (last-pair b)) [be])
         (cons bb b)))
   #+end_src

   POST is a whitespace character, ~-~, ~.~, ~,~, ~:~, ~!~, ~?~, ~'~,
   ~)~, ~}~ or a double quote.  It can also be an end of line.
 
   #+begin_src gerbil
     (def POST (.or (sat (cut string-any <> " -,.:!?')}\""))
                    (peek #\newline)))

   #+end_src
   


   #+ATTR_ASCII: :width 5
   -----
   
   #+BEGIN_QUOTE
   All of this is wrong if ~org-emphasis-regexp-components~ or
   ~org-emphasis-alist~ are modified.

   This should really be simplified.

   Also, CONTENTS should be anything within code and verbatim
   emphasis, by definition.  --- ngz
   #+END_QUOTE


* STARTED /File/ syntax.ss

#+begin_src gerbil :noweb yes :tangle "syntax.ss"
  (import :drewc/smug :std/srfi/13 :std/srfi/1
          :drewc/org/environment)
  (export (import: <global>) (import: <headline>)
          (import: <affiliated-keywords>) (import: <timestamp>)
          (import: <tables>) (import: <planning>)
          (import: <drawers>) (import: <property-drawers>) (import: <emphasis>))

  (module <global>
    (export #t)
    <<ANY-STRING>>
    <<global>>)
  (import <global>)

  ;; * Objects

  (module <timestamp>
    (import <global>)
    (export TIMESTAMP)
    <<timestamp-code>>
    <<REPEATER-OR-DELAY>>
    <<TIMESTAMP>>)
  (import <timestamp>)

  (module <emphasis>
    (import <global>)
    (export TEXT-MARKUP)
    <<emphasis-markers>>
    <<TEXT-MARKUP>>)
  (import <emphasis>)

 ;; ** Planning

  (module <planning> 
    (import <timestamp>)
    (export PLANNING-KEYWORD PLANNING)
    <<PLANNING-KEYWORD>>
    <<PLANNING>>)
  (import <planning>)

  ;; * Headlines and Sections
  (module <headline>
    (import <global>)
    (export HEADLINE HEADLINE-ELEMENT STARS STARS-ONLY)
    <<headlines-and-sections>>
    <<headline>>)
  (import <headline>)

  ;; * Affiliated Keywords

  (module <affiliated-keywords>
     (import <global>)
     (export AFFILIATED-KEYWORD
             (rename: KEY AFFILIATED-KEY))
     <<affiliated-keywords>>
     <<afk>>)
  (import <affiliated-keywords>)

  ;; * Greater Elements

  ;; ** Tables

  (module <tables>
    (import <global>)
    (export TABLE TBLFM)
    <<table-cells>>
    <<table-row>>
    <<table-fm>>
    <<table-parser>>)
  (import <tables>)

  ;; ** Drawers and Property Drawers

  (module <drawers>
    (import <global>)
     (export DRAWER-DELIMITER DRAWER-START DRAWER-END)
      <<drawers-code>>)
  (import <drawers>)

  (module <property-drawers> 
    (import <global> <drawers>)++
    (export PROPERTYDRAWER PROPERTYDRAWER-START PROPERTYDRAWER-CONTENTS PROPERTYDRAWER-END)
    <<node-property>>
    <<PROPERTYDRAWER-CONTENTS>>
    <<PROPERTYDRAWER>>)
  (import <property-drawers>)


  ;; Greater Blocks

  (module <all-blocks>
    (export #t)
    <<all-blocks>>)

  ;; * Elements

  ;; ** Blocks 
  (module <block> 
  (import <global>)
    (export BLOCK)
    <<blocks-code>>)
  (import <block>)

 

  


#+end_src
* Copyright

Documentation from the orgmode.org/worg/ website (either in its HTML format or
in its Org format) is licensed under the GNU Free Documentation License version
1.3 or later

Copyright (C) 2019 Drew Crampsie.
    Permission is granted to copy, distribute and/or modify this document
    under the terms of the GNU Free Documentation License, Version 1.3
    or any later version published by the Free Software Foundation;
    with no Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts.
    A copy of the license is included in the section entitled "GNU
    Free Documentation License".


** History 

#+begin_src org
  ,#+TITLE: Org Syntax (draft)
  ,#+AUTHOR: Nicolas Goaziou
  ,#+CATEGORY: worg
#+end_src

* Footnotes

[fn:omtr] Org Manual - Repeated Tasks
 https://orgmode.org/manual/Repeated-tasks.html#Repeated-tasks

[fn:ol] Org Manual - Literal Examples
https://orgmode.org/manual/Literal-Examples.html#Literal-Examples

[fn:1] In particular, the parser requires stars at column 0 to be
quoted by a comma when they do not define a headline.

[fn:2] It also means that only headlines and sections can be
recognized just by looking at the beginning of the line.  Planning
lines and property drawers can be recognized by looking at one or two
lines above.

As a consequence, using ~org-element-at-point~ or
~org-element-context~ will move up to the parent headline, and parse
top-down from there until context around original location is found.


# Local Variables:
# sentence-end-double-space: t
# End:

